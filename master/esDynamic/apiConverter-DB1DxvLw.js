import{a as m,e as G}from"./Transformation2D-Dqu-RtOz.js";import{r as X,C as Y,e as h,M as b,U as k}from"./ProjectionTransformation-DKC-VGdP.js";import{bz as I,bP as N,bC as p,bO as S,aQ as q}from"./main-BC8gbEPx.js";import{fromGeometryToGXGeometry as g,toGeometry as y}from"./jsonConverter-C4JGLtD-.js";const s="_gxVersion",C=2,x=1;function A(e){return Array.isArray(e)?e[0].spatialReference:e.spatialReference}function D(e){switch(e.type){case"point":return w(e);case"multipoint":return V(e);case"polyline":return Z(e);case"polygon":return P(e);case"extent":return M(e);default:throw new Error(`Unsupported geometry type: ${e.type}`)}}function M(e){if(!e.getCacheValue(s)){const n=new X;n.setCoords(e.xmin,e.ymin,e.xmax,e.ymax),e.hasM&&n.setInterval(C,0,e.mmin,e.mmax),e.hasZ&&n.setInterval(x,0,e.zmin,e.zmax),e.setCacheValue(s,n)}return e.getCacheValue(s)}function V(e){if(!e.getCacheValue(s)){const n=new Y,a=new h,r=e.points,t=e.hasM,o=e.hasZ,i=o?3:2;for(let u=0,l=r.length;u<l;u++){const c=r[u];a.setXYCoords(c[0],c[1]),o&&a.setZ(c[2]??0),t&&a.setM(c[i]??NaN),n.add(a)}e.setCacheValue(s,n)}return e.getCacheValue(s)}function w(e){if(!e.getCacheValue(s)){const n=new h;n.setXYCoords(e.x,e.y),e.hasM&&n.setM(e.m),e.hasZ&&n.setZ(e.z),e.setCacheValue(s,n)}return e.getCacheValue(s)}function P(e){if(!e.getCacheValue(s)){const{curveRings:n,hasM:a,hasZ:r,rings:t}=e,o=g({curveRings:n,hasM:a,hasZ:r,rings:t});e.setCacheValue(s,o)}return e.getCacheValue(s)}function Z(e){if(!e.getCacheValue(s)){const{curvePaths:n,hasM:a,hasZ:r,paths:t}=e,o=g({curvePaths:n,hasM:a,hasZ:r,paths:t});e.setCacheValue(s,o)}return e.getCacheValue(s)}function J(e){if(e.wkid)return b(e.wkid);const n=e.wkt2||e.wkt;return n?k(n):null}function O(e,n){if(e)switch(e.getGeometryType()){case m.enumPoint:return d(e,n);case m.enumEnvelope:return v(e,n);case m.enumMultiPoint:return R(e,n);case m.enumPolyline:return z(e,n);case m.enumPolygon:return E(e,n)}return null}function v(e,n){if(e.isEmpty())return null;const a=new I({xmin:e.getXMin(),ymin:e.getYMin(),xmax:e.getXMax(),ymax:e.getYMax(),spatialReference:n}),r=e.getDescription();if(r.hasM()){const t=e.queryInterval(C,0);a.mmin=t.vmin,a.mmax=t.vmax}if(r.hasZ()){const t=e.queryInterval(x,0);a.zmin=t.vmin,a.zmax=t.vmax}return a.setCacheValue(s,e),a}function R(e,n){if(e.isEmpty())return null;const a=e.getDescription(),r=a.hasM(),t=a.hasZ(),o=[],i=new h;for(let l=0,c=e.getPointCount();l<c;l++){e.getPointByVal(l,i);const f=[i.getX(),i.getY()];t&&f.push(i.getZ()),r&&f.push(i.getM()),o.push(f)}const u=new N({hasM:r,hasZ:t,points:o,spatialReference:n});return u.setCacheValue(s,e),u}function d(e,n){if(e instanceof G)return new p({x:e.x,y:e.y,spatialReference:n});if(e.isEmpty())return null;const a=new p({x:e.getX(),y:e.getY(),spatialReference:n}),r=e.getDescription();return r.hasM()&&(a.m=e.getM()),r.hasZ()&&(a.z=e.getZ()),a.setCacheValue(s,e),a}function E(e,n){if(e.isEmpty())return null;const a=S.fromJSON({spatialReference:n,...y(e,null)});return a.setCacheValue(s,e),a}function z(e,n){if(e.isEmpty())return null;const a=q.fromJSON({spatialReference:n,...y(e,null)});return a.setCacheValue(s,e),a}export{M as fromExtent,D as fromGeometry,V as fromMultipoint,w as fromPoint,P as fromPolygon,Z as fromPolyline,J as fromSpatialReference,A as getSpatialReference,v as toExtent,O as toGeometry,R as toMultipoint,d as toPoint,E as toPolygon,z as toPolyline};
