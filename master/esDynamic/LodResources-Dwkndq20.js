import{cI as J,aI as _,dw as z,hY as x}from"./main-BC8gbEPx.js";import{y as H,i as X}from"./memoryEstimations-Cij6FoJa.js";import{n as B}from"./mat4-BDUaQr32.js";import{e as Q,o as I}from"./mat4f64-BaJwL7tQ.js";import{u as S,E as R,g as U,r as Y,s as E,A as k}from"./vec32-CKLwdlap.js";import{z as q}from"./vec42-D8CJyqHG.js";import{n as F}from"./vec4f64-CjUMzAyX.js";import{b as p,S as K,v as T}from"./sphere-BQalhKXp.js";import{l as M}from"./ViewingMode-CyR_b1T8.js";import{s as Z,e as w,i as f}from"./IntersectorInterfaces-9nlZxCRy.js";import"./boundedPlane-BSNdaYKJ.js";import{b as $,d as N}from"./Geometry-6d2Fi3Pn.js";import{e as tt}from"./VertexAttribute-DFC3a3eR.js";class rt{constructor(t,r,e){this.object=t,this.geometryId=r,this.triangleNr=e}}class et extends rt{constructor(t,r,e,s){super(t,r,e),this.center=s!=null?J(s):null}}class st{constructor(t){this.layerUid=t}}let it=class extends st{constructor(i,t){super(i),this.graphicUid=t}};function V(i){return i?.dist!=null}const j=1e-5;class nt{constructor(t){this.options=new Z,this._results=new ot,this.transform=new $,this.tolerance=j,this.verticalOffset=null,this._ray=p(),this._rayEnd=_(),this._rayBeginTransformed=_(),this._rayEndTransformed=_(),this.viewingMode=t??M.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,r,e){this.resetWithRay(K(t,r,this._ray),e)}resetWithRay(t,r){this.camera=r,t!==this._ray&&T(t,this._ray),this.options.verticalOffset!==0?this.viewingMode===M.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,S(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(t=null,r,e,s,n){this.point=r,this.filterPredicate=s,this.tolerance=e??j;const a=N(this.verticalOffset);if(t&&t.length>0){const o=n?h=>{n(h)&&this.intersectObject(h)}:h=>{this.intersectObject(h)};for(const h of t){const u=h.getSpatialQueryAccelerator?.();u!=null?(a!=null?u.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,o,a):u.forEachAlongRay(this._ray.origin,this._ray.direction,o),this.options.selectionMode&&this.options.hud&&u.forEachDegenerateObject(o)):h.objects.forAll(l=>o(l))}}this.sortResults()}intersectObject(t){const r=t.geometries;if(!r)return;const e=t.effectiveTransformation,s=N(this.verticalOffset);for(const n of r){if(!n.visible)continue;const{material:a,id:o}=n;if(!a.visible)continue;this.transform.setAndInvalidateLazyTransforms(e,n.transformation),R(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),R(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const h=this.transform.transform;s!=null&&(s.objectTransform=this.transform),a.intersect(n,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(u,l,m,y,g,b)=>{if(u>=0){if(this.filterPredicate!=null&&!this.filterPredicate(this._ray.origin,this._rayEnd,u))return;const c=y?this._results.hud:this._results,v=y?d=>{const P=new et(t,o,m,b);d.set(f.HUD,P,u,l,I,g)}:d=>d.set(f.OBJECT,{object:t,geometryId:o,triangleNr:m},u,l,h,g);if((c.min.drapedLayerOrder==null||g>=c.min.drapedLayerOrder)&&(c.min.dist==null||u<c.min.dist)&&v(c.min),this.options.store!==w.MIN&&(c.max.drapedLayerOrder==null||g<c.max.drapedLayerOrder)&&(c.max.dist==null||u>c.max.dist)&&v(c.max),this.options.store===w.ALL)if(y){const d=new A(this._ray);v(d),this._results.hud.all.push(d)}else{const d=new O(this._ray);v(d),this._results.all.push(d)}}})}}sortResults(t=this._results.all){t.sort((r,e)=>r.dist!==e.dist?(r.dist??0)-(e.dist??0):r.drapedLayerOrder!==e.drapedLayerOrder?C(r.drapedLayerOrder,e.drapedLayerOrder):C(r.drapedLayerGraphicOrder,e.drapedLayerGraphicOrder))}}function C(i,t){return(t??-Number.MAX_VALUE)-(i??-Number.MAX_VALUE)}function at(i){return new nt(i)}class ot{constructor(){this.min=new O(p()),this.max=new O(p()),this.hud={min:new A(p()),max:new A(p()),all:new Array},this.ground=new O(p()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}class O{get ray(){return this._ray}get distanceInRenderSpace(){return this.dist!=null?(U(G,this.ray.direction,this.dist),Y(G)):null}withinDistance(t){return!!V(this)&&this.distanceInRenderSpace<=t}getIntersectionPoint(t){return!!V(this)&&(U(G,this.ray.direction,this.dist),S(t,this.ray.origin,G),!0)}getTransformedNormal(t){return E(L,this.normal),L[3]=0,q(L,L,this.transformation),E(t,L),k(t,t)}constructor(t){this.intersector=f.OBJECT,this.normal=_(),this.transformation=Q(),this._ray=p(),this.init(t)}init(t){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=f.OBJECT,T(t,this._ray)}set(t,r,e,s,n,a,o){this.intersector=t,this.dist=e,E(this.normal,s??z),B(this.transformation,n??I),this.target=r,this.drapedLayerOrder=a,this.drapedLayerGraphicOrder=o}copy(t){T(t.ray,this._ray),this.intersector=t.intersector,this.dist=t.dist,this.target=t.target,this.drapedLayerOrder=t.drapedLayerOrder,this.drapedLayerGraphicOrder=t.drapedLayerGraphicOrder,E(this.normal,t.normal),B(this.transformation,t.transformation)}}class A extends O{constructor(){super(...arguments),this.intersector=f.HUD}}function ht(i){return new O(i)}const G=_(),L=F();class ut extends it{constructor(t,r,e,s,n){super(t,r),this.layerUid=t,this.graphicUid=r,this.triangleNr=e,this.baseBoundingSphere=s,this.numLodLevels=n}}class W{constructor(t,r,e,s){this.material=t,this.bufferWriter=t.createBufferWriter(),this.vertexBufferLayout=this.bufferWriter.vertexBufferLayout,this.buffer=r,this.elementCount=e,this.boundingInfo=s}get numTriangles(){return this.elementCount/3}get numVertices(){return this.elementCount}computeUsedMemory(){return this.buffer.byteLength+H}getRenderGeometry(){return this}intersect(t,r,e,s,n,a,o,h){const u=this.bufferWriter,l=this.buffer;u.intersect(l,t,e,s,(m,y,g,b,c)=>D(m,y,g,c,t,r,a,o,n,h))}}class lt{constructor(t){this.engineGeometry=t}get material(){return this.engineGeometry.material}get numVertices(){return this.engineGeometry.attributes.get(tt.POSITION).indices.length}get numTriangles(){return this.engineGeometry.indexCount/3}get boundingInfo(){return this.engineGeometry.boundingInfo}computeUsedMemory(){return Array.from(this.engineGeometry.attributes.values()).reduce((t,r)=>t+X(r.data,r.indices),0)}getRenderGeometry(){const t=this.material,r=this.engineGeometry,e=r.attributes,s=r.boundingInfo,n=t.createBufferWriter(),a=n.vertexBufferLayout,o=n.elementCount(e),h=a.createBuffer(o);return n.write(null,null,e,null,h,0),new W(t,h.buffer,o,s)}intersect(t,r,e,s,n,a,o,h){const u=this.engineGeometry;this.material.intersect(u,t.transform.transform,t,e,s,(l,m,y,g,b)=>D(l,m,y,b,t,r,a,o,n,h))}}function D(i,t,r,e,s,n,a,o,h,u){if(i<0||n&&!n(s.rayBegin,s.rayEnd,i))return;const l=new ut(a.layerUid,a.graphicUid(h),r,o,u);if((s.results.min.drapedLayerOrder==null||e>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||i<s.results.min.dist)&&s.results.min.set(f.LOD,l,i,t,s.transform.transform,e),s.options.store!==w.MIN&&(s.results.max.drapedLayerOrder==null||e>=s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||i>s.results.max.dist)&&s.results.max.set(f.LOD,l,i,t,s.transform.transform,e),s.options.store===w.ALL){const m=ht(s.results.min.ray);m.set(f.LOD,l,i,t,s.transform.transform,e),s.results.all.push(m)}}class ct{constructor(t,r=null){this.geometry=t,this.textures=r}get material(){return this.geometry.material}get numTriangles(){return this.geometry.numTriangles}}class mt{constructor(t,r,e){this.components=t,this.minScreenSpaceRadius=r,this.pivotOffset=e;const s=x(this.components.map(n=>n.geometry));this.numVertices=s.reduce((n,a)=>n+a.numVertices,0)}}class dt{constructor(t){this.levels=t,this.levels.sort((r,e)=>r.minScreenSpaceRadius===e.minScreenSpaceRadius?r.numVertices-e.numVertices:r.minScreenSpaceRadius-e.minScreenSpaceRadius)}getMaterials(){const t=[];return this.levels.forEach(r=>r.components.forEach(e=>t.push(e.geometry.material))),x(t)}getTextures(){const t=new Array;return this.levels.forEach(r=>r.components.forEach(e=>{e.textures!=null&&t.push(...e.textures)})),x(t)}getGeometries(){const t=new Array;return this.levels.forEach(r=>r.components.forEach(e=>{t.push(e.geometry)})),x(t)}getEngineGeometries(){return this.getGeometries().map(t=>t.engineGeometry).filter(t=>t!=null)}computeUsedMemory(){const t=this.getGeometries(),r=this.getTextures(),e=t.reduce((s,n)=>s+n.computeUsedMemory(),0);return r.reduce((s,n)=>s+n.memoryEstimate,0)+e}}export{at as T,lt as a,mt as f,dt as h,ct as l,W as m};
