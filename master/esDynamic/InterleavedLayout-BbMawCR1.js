import{y as c,u as p,i as _,c as m,l as y,p as F,o as g,m as w,T as b,h as E,a as v,b as A,d as M,A as T,O as I,x as $,g as z,w as S,E as j,L as B,B as C,F as q,I as D,U as J,j as L,V as U,M as K,S as N,k as O,q as k,v as P,z as Q,C as R,D as W,G as X,H as Y}from"./BufferView-BaIKDMOo.js";import{e as x}from"./types-ChhhI6OU.js";import{n as Z}from"./vec2f64-CEUyUoff.js";import"./vec42-D8CJyqHG.js";import"./vec4f64-CjUMzAyX.js";class tt{constructor(t){this.message=t}toString(){return`AssertException: ${this.message}`}}function V(s,t="Assertion"){if(!s){const e=new Error(t).stack;throw new tt(`${t} at ${e}`)}}function et(s,t){s||(t=t||"",console.warn("Verify failed: "+t+`
`+new Error("verify").stack))}function st(s,t,e,i){let r,n=(e[0]-s[0])/t[0],a=(i[0]-s[0])/t[0];n>a&&(r=n,n=a,a=r);let u=(e[1]-s[1])/t[1],h=(i[1]-s[1])/t[1];if(u>h&&(r=u,u=h,h=r),n>h||u>a)return!1;u>n&&(n=u),h<a&&(a=h);let o=(e[2]-s[2])/t[2],d=(i[2]-s[2])/t[2];return o>d&&(r=o,o=d,d=r),!(n>d||o>a)&&(d<a&&(a=d),!(a<0))}function rt(s,t,e,i,r,n=Z()){const a=(i[r]-e[r])*(t[0]-s[0])-(i[0]-e[0])*(t[r]-s[r]),u=(i[0]-e[0])*(s[r]-e[r])-(i[r]-e[r])*(s[0]-e[0]);if(a===0)return!1;const h=u/a;return n[0]=s[0]+h*(t[0]-s[0]),n[1]=s[r]+h*(t[r]-s[r]),!0}function it(s,t){return Math.log(s)/Math.log(t)}function nt(s){return s[0]===1&&s[1]===0&&s[2]===0&&s[3]===0&&s[4]===0&&s[5]===1&&s[6]===0&&s[7]===0&&s[8]===0&&s[9]===0&&s[10]===1&&s[11]===0&&s[15]===1}class f{constructor(t,e){this.layout=t,this.buffer=typeof e=="number"?new ArrayBuffer(e*t.stride):e;for(const i of t.fields.keys()){const r=t.fields.get(i);this[i]=new r.constructor(this.buffer,r.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,e){const i=this[t];return i&&i.elementCount===e.ElementCount&&i.elementType===e.ElementType?i:null}slice(t,e){return new f(this.layout,this.buffer.slice(t*this.stride,e*this.stride))}copyFrom(t,e=0,i=0,r=t.count){const n=this.stride;if(n%4==0){const a=new Uint32Array(t.buffer,e*n,r*n/4);new Uint32Array(this.buffer,i*n,r*n/4).set(a)}else{const a=new Uint8Array(t.buffer,e*n,r*n);new Uint8Array(this.buffer,i*n,r*n).set(a)}return this}get cachedMemory(){return this.byteLength}dispose(){}}class l{constructor(t){this._stride=0,this._lastAligned=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach(e=>this._fields.set(e[0],{...e[1],constructor:dt(e[1].constructor)})))}freeze(){return this}vec2f(t,e){return this._appendField(t,p,e),this}vec2f64(t,e){return this._appendField(t,w,e),this}vec3f(t,e){return this._appendField(t,_,e),this}vec3f64(t,e){return this._appendField(t,b,e),this}vec4f(t,e){return this._appendField(t,m,e),this}vec4f64(t,e){return this._appendField(t,E,e),this}mat3f(t,e){return this._appendField(t,y,e),this}mat3f64(t,e){return this._appendField(t,v,e),this}mat4f(t,e){return this._appendField(t,F,e),this}mat4f64(t,e){return this._appendField(t,A,e),this}vec4u8(t,e){return this._appendField(t,$,e),this}f32(t,e){return this._appendField(t,c,e),this}f64(t,e){return this._appendField(t,g,e),this}u8(t,e){return this._appendField(t,M,e),this}u16(t,e){return this._appendField(t,z,e),this}i8(t,e){return this._appendField(t,L,e),this}vec2i8(t,e){return this._appendField(t,U,e),this}vec2i16(t,e){return this._appendField(t,k,e),this}vec2u8(t,e){return this._appendField(t,T,e),this}vec4u16(t,e){return this._appendField(t,B,e),this}u32(t,e){return this._appendField(t,C,e),this}_appendField(t,e,i){if(this._fields.has(t))return void V(!1,`${t} already added to vertex buffer layout`);const r=e.ElementCount*x(e.ElementType),n=this._stride;this._stride+=r,this._fields.set(t,{size:r,constructor:e,offset:n,optional:i})}createBuffer(t){return new f(this,t)}createView(t){return new f(this,t)}clone(){const t=new l;return t._stride=this._stride,t._fields=new Map,this._fields.forEach((e,i)=>t._fields.set(i,e)),t.BufferType=this.BufferType,t}get stride(){if(this._lastAligned!==this._fields.size){let t=1;this._fields.forEach(e=>t=Math.max(t,x(e.constructor.ElementType))),this._stride=Math.floor((this._stride+t-1)/t)*t,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}function at(){return new l}class ht{constructor(t){this.fields=new Array,t.fields.forEach((e,i)=>{const r={...e,constructor:G(e.constructor)};this.fields.push([i,r])}),this.stride=t.stride}}const ut=[c,p,_,m,y,F,g,w,b,E,v,A,M,T,I,$,z,S,j,B,C,q,D,J,L,U,K,N,O,k,P,Q,R,W,X,Y];function G(s){return`${s.ElementType}_${s.ElementCount}`}function dt(s){return H.get(s)}const H=new Map;ut.forEach(s=>H.set(G(s),s));export{l as G,at as H,ht as I,et as c,rt as f,st as i,nt as m,V as s,it as u};
