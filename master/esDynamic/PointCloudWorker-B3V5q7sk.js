import{fk as O,b$ as k,M as v}from"./main-BC8gbEPx.js";import{O as x}from"./quat-DCeYU0hU.js";import{e as C}from"./quatf64-C16JxGFv.js";import{Q as F}from"./vec32-CKLwdlap.js";import{t as A,n as w}from"./vec3f32-BS0cezmI.js";import{o as R}from"./projectBuffer-CI8y-xLT.js";import{d as U,a as B,b as J}from"./PointCloudUniqueValueRenderer-FUCehpWL.js";import{w as N,l as V,c as T,I as q}from"./I3SBinaryReader-Dh23TGHI.js";import{I as z}from"./orientedBoundingBox-Cx1yARP6.js";function E(i,e,a,n){const{rendererJSON:c,isRGBRenderer:m}=i;let t=null,s=null;if(e&&m)t=e;else if(e&&c?.type==="pointCloudUniqueValueRenderer"){s=U.fromJSON(c);const r=s.colorUniqueValueInfos;t=new Uint8Array(3*n);const f=g(s.fieldTransformType);for(let o=0;o<n;o++){const l=(f?f(e[o]):e[o])+"";for(let u=0;u<r.length;u++)if(r[u].values.includes(l)){t[3*o]=r[u].color.r,t[3*o+1]=r[u].color.g,t[3*o+2]=r[u].color.b;break}}}else if(e&&c?.type==="pointCloudStretchRenderer"){s=B.fromJSON(c);const r=s.stops;t=new Uint8Array(3*n);const f=g(s.fieldTransformType);for(let o=0;o<n;o++){const l=f?f(e[o]):e[o],u=r.length-1;if(l<r[0].value)t[3*o]=r[0].color.r,t[3*o+1]=r[0].color.g,t[3*o+2]=r[0].color.b;else if(l>=r[u].value)t[3*o]=r[u].color.r,t[3*o+1]=r[u].color.g,t[3*o+2]=r[u].color.b;else for(let b=1;b<r.length;b++)if(l<r[b].value){const p=(l-r[b-1].value)/(r[b].value-r[b-1].value);t[3*o]=r[b].color.r*p+r[b-1].color.r*(1-p),t[3*o+1]=r[b].color.g*p+r[b-1].color.g*(1-p),t[3*o+2]=r[b].color.b*p+r[b-1].color.b*(1-p);break}}}else if(e&&c?.type==="pointCloudClassBreaksRenderer"){s=J.fromJSON(c);const r=s.colorClassBreakInfos;t=new Uint8Array(3*n);const f=g(s.fieldTransformType);for(let o=0;o<n;o++){const l=f?f(e[o]):e[o];for(let u=0;u<r.length;u++)if(l>=r[u].minValue&&l<=r[u].maxValue){t[3*o]=r[u].color.r,t[3*o+1]=r[u].color.g,t[3*o+2]=r[u].color.b;break}}}else t=new Uint8Array(3*n).fill(255);if(a&&s?.colorModulation){const r=s.colorModulation.minValue,f=s.colorModulation.maxValue,o=.3;for(let l=0;l<n;l++){const u=a[l],b=u>=f?1:u<=r?o:o+(1-o)*(u-r)/(f-r);t[3*l]=b*t[3*l],t[3*l+1]=b*t[3*l+1],t[3*l+2]=b*t[3*l+2]}}return t}function X(i,e){if(i.encoding==null||i.encoding===""){const a=N(e,i);if(a.vertexAttributes.position==null)return;const n=V(e,a.vertexAttributes.position),c=a.header.fields,m=[c.offsetX,c.offsetY,c.offsetZ],t=[c.scaleX,c.scaleY,c.scaleZ],s=n.length/3,r=new Float64Array(3*s);for(let f=0;f<s;f++)r[3*f]=n[3*f]*t[0]+m[0],r[3*f+1]=n[3*f+1]*t[1]+m[1],r[3*f+2]=n[3*f+2]*t[2]+m[2];return r}if(i.encoding==="lepcc-xyz")return T(e).result}function h(i,e,a){return i?.attributeInfo.useElevation?e?Y(e,a):null:i?.attributeInfo.storageInfo?q(i.attributeInfo.storageInfo,i.buffer,a):null}function Y(i,e){const a=new Float64Array(e);for(let n=0;n<e;n++)a[n]=i[3*n+2];return a}function Z(i,e,a,n,c){const m=i.length/3;let t=0;for(let s=0;s<m;s++){let r=!0;for(let f=0;f<n.length&&r;f++){const{filterJSON:o}=n[f],l=c[f].values[s];switch(o.type){case"pointCloudValueFilter":{const u=o.mode==="exclude";o.values.includes(l)===u&&(r=!1);break}case"pointCloudBitfieldFilter":{const u=M(o.requiredSetBits),b=M(o.requiredClearBits);((l&u)!==u||l&b)&&(r=!1);break}case"pointCloudReturnFilter":{const u=15&l,b=l>>>4&15,p=b>1,S=u===1,y=u===b;let I=!1;for(const d of o.includedReturns)if(d==="last"&&y||d==="firstOfMany"&&S&&p||d==="lastOfMany"&&y&&p||d==="single"&&!p){I=!0;break}I||(r=!1);break}}}r&&(a[t]=s,i[3*t]=i[3*s],i[3*t+1]=i[3*s+1],i[3*t+2]=i[3*s+2],e[3*t]=e[3*s],e[3*t+1]=e[3*s+1],e[3*t+2]=e[3*s+2],t++)}return t}function g(i){switch(i){default:case null:case"none":return e=>e;case"low-four-bit":return e=>15&e;case"high-four-bit":return e=>(240&e)>>4;case"absolute-value":return e=>Math.abs(e);case"modulo-ten":return e=>e%10}}function M(i){let e=0;for(const a of i||[])e|=1<<a;return e}class _{transform(e){const a=this._transform(e),n=[a.points.buffer,a.rgb.buffer];a.pointIdFilterMap!=null&&n.push(a.pointIdFilterMap.buffer);for(const c of a.attributes)"buffer"in c.values&&O(c.values.buffer)&&c.values.buffer!==a.rgb.buffer&&n.push(c.values.buffer);return Promise.resolve({result:a,transferList:n})}_transform(e){const a=X(e.schema,e.geometryBuffer);let n=a.length/3,c=null;const m=new Array,t=h(e.primaryAttributeData,a,n);e.primaryAttributeData!=null&&t&&m.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:t});const s=h(e.modulationAttributeData,a,n);e.modulationAttributeData!=null&&s&&m.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:s});let r=E(e.rendererInfo,t,s,n);if(e.filterInfo&&e.filterInfo.length>0&&e.filterAttributesData!=null){const o=e.filterAttributesData.filter(k).map(l=>{const u=h(l,a,n),b={attributeInfo:l.attributeInfo,values:u};return m.push(b),b});c=new Uint32Array(n),n=Z(a,r,c,e.filterInfo,o)}for(const o of e.userAttributesData){const l=h(o,a,n);m.push({attributeInfo:o.attributeInfo,values:l})}3*n<r.length&&(r=new Uint8Array(r.buffer.slice(0,3*n))),$(a,n,e.elevationOffset);const f=G(a,n,z.fromData(e.obbData),v.fromJSON(e.inSR),v.fromJSON(e.outSR));return{obbData:e.obbData,points:f,rgb:r,attributes:m,pointIdFilterMap:c}}}function G(i,e,a,n,c){if(!R(i,n,0,i,c,0,e))throw new Error("Can't reproject");const m=A(a.center),t=w(),s=w(),r=A(a.halfSize);x(D,a.quaternion);const f=new Float32Array(3*e);for(let o=0;o<e;o++){let l=3*o;t[0]=i[l]-m[0],t[1]=i[l+1]-m[1],t[2]=i[l+2]-m[2],F(s,t,D),r[0]=Math.max(r[0],Math.abs(s[0])),r[1]=Math.max(r[1],Math.abs(s[1])),r[2]=Math.max(r[2],Math.abs(s[2])),f[l++]=t[0],f[l++]=t[1],f[l]=t[2]}return a.halfSize=r,f}function $(i,e,a){if(a!==0)for(let n=0;n<e;n++)i[3*n+2]+=a}const D=C();function j(){return new _}export{j as default};
