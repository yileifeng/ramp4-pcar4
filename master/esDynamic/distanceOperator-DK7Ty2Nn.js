import{a as c,e as P,M as v,w as A,m as T,c as z,aM as R,L as ie,O as C,j as U}from"./Transformation2D-Dqu-RtOz.js";import{d2 as H,d3 as J,e0 as se}from"./main-BC8gbEPx.js";import{e as G,n as E,r as K,ac as w,ag as re,aU as oe,a as me}from"./ProjectionTransformation-DKC-VGdP.js";import{fromGeometry as Q,getSpatialReference as ae}from"./apiConverter-DB1DxvLw.js";import"./jsonConverter-C4JGLtD-.js";function j(){return{outPoint:new P,index:-1,t:Number.NaN}}function Y(a,e,t){return{outPoint:a.clone(),index:e,t}}function l(a,e,t,n){a.outPoint.assign(e),a.index=t,a.t=n}function S(a,e){a.outPoint.assign(e.outPoint),a.index=e.index,a.t=e.t}function W(a,e,t,n){a.index=t,a.t=n,e.queryCoord2D(a.t,a.outPoint)}function F(a,e){const t=j();S(t,a),S(a,e),S(e,t)}function ue(a,e,t,n,i,r){if(a.getGeometryType()===c.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const s=n.nextSegment();if(w(a,s.getEndXY(),0)!==0)return l(i,s.getEndXY(),-1,Number.NaN),l(r,s.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}if(e.getGeometryType()===c.enumPolygon){for(;t.nextPath();)if(t.hasNextSegment()){const s=t.nextSegment();if(w(e,s.getEndXY(),0)!==0)return l(i,s.getEndXY(),-1,Number.NaN),l(r,s.getEndXY(),-1,Number.NaN),!0}t.resetToFirstPath()}return!1}function ce(a){const e=a.getPathCount(),t=ie(a.getSegmentCount(),0);let n=0;for(let i=0;i<e;++i){const r=n+a.getSegmentCountPath(i);for(let s=n,m=a.getPathStart(i);s<r;++s,++m)t[s]=m;n=r}return oe(a.getPointCount(),t),t}function Z(a,e){return!!Number.isNaN(e)||a<=e}function O(a){const e=new me;return e.addEnvelope(a,!1),e}class he{constructor(e,t){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=t,this.m_maxSqrDistance=e*e,this.m_maxDistance=e,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=e,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let n=Math.sqrt(this.m_maxSqrDistance);for(;n<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,n=Math.sqrt(this.m_maxSqrDistance)}}calculate(e,t,n,i){if((e.getGeometryType()!==G.type||t.getGeometryType()!==G.type)&&(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!Z(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const r=Y(new P,C(),Number.NaN),s=Y(new P,C(),Number.NaN),m=this._ExecuteBruteForce(e,t,r,s);return Z(m,this.m_maxDistance)?(n!==null&&S(n,r),i!==null&&S(i,s),m):Number.POSITIVE_INFINITY}isNear(e,t){if(this.m_bIsNearCalc=!0,e.isEmpty()||t.isEmpty())return!1;if(e===t)return!0;let n=!0;if(e.getGeometryType()!==G.type&&e.getGeometryType()!==K.type||t.getGeometryType()!==G.type&&t.getGeometryType()!==K.type||(n=!1),n){if(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const i=Y(new P,C(),Number.NaN),r=Y(new P,C(),Number.NaN);return this._ExecuteBruteForce(e,t,i,r)<=this.m_maxDistance}progress_(e=!1){}_ExecuteBruteForce(e,t,n,i){switch(e.getGeometryType()){case c.enumPoint:return this.distancePointGeometry(e,t,n,i);case c.enumMultiPoint:return this.distanceMultipointGeometry(e,t,n,i);case c.enumEnvelope:return this.distanceEnvelopeGeometry(e,t,n,i);case c.enumPolyline:case c.enumPolygon:return this.distanceMultipathGeometry(e,t,n,i);default:return Number.NaN}}distancePointGeometry(e,t,n,i){switch(t.getGeometryType()){case c.enumPoint:return this.distancePointPoint(e,t,n,i);case c.enumMultiPoint:return this.distancePointMultipoint(e,t,n,i);case c.enumPolyline:case c.enumPolygon:return this.distancePointMultipath(e,t,n,i);case c.enumEnvelope:return this.distancePointEnvelope(e,t,n,i);default:return Number.NaN}}distancePointPoint(e,t,n,i){const r=e.getXY(),s=t.getXY();return l(n,r,0,0),l(i,s,0,0),Math.sqrt(P.sqrDistance(r,s))}distancePointMultipoint(e,t,n,i){const r=e.getXY();let s=this.m_maxSqrDistance,m=s,o=!1;const u=t.getPointCount(),y=new P;for(let _=0;_<u;++_)if(t.queryXY(_,y),m=P.sqrDistance(r,y),this.m_bIsNearCalc){if(m<=s)return 0}else if(!(m>s)&&(!o&&m===s||m<s)&&(s=m,l(n,r,0,0),l(i,y,_,0),o=!0,s===0))return 0;return o?Math.sqrt(s):Number.POSITIVE_INFINITY}distancePointMultipath(e,t,n,i){const r=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),s=e.getXY();if(!r&&t.getGeometryType()===c.enumPolygon&&w(t,s,0)!==0)return l(n,s,0,0),l(i,s,-1,Number.NaN),0;t.getImpl().getAccelerators();let m=this.m_maxSqrDistance,o=m,u=-1;const y=new E,_=t.querySegmentIterator();let h=!1;for(;_.nextPath();)for(;_.hasNextSegment();){const p=_.nextSegment();p.queryEnvelope(y);const x=y.sqrDistance(s);if(x>m||!this.m_bIsNearCalc&&h&&x===m)continue;u=p.getClosestCoordinate(s,!1);const g=p.getCoord2D(u);if(o=P.sqrDistance(s,g),this.m_bIsNearCalc){if(o<=m)return 0}else if(!(o>m)&&(!h||o<m)&&(m=o,l(n,s,0,0),l(i,g,_.getStartPointIndex(),u),h=!0,m===0))return 0}return h?Math.sqrt(m):Number.POSITIVE_INFINITY}distancePointEnvelope(e,t,n,i){const r=e.getXY();l(n,r,0,0),l(i,r,-1,Number.NaN);const s=t.asEnvelope2D();return s.contains(r)?0:Math.sqrt(s.sqrDistance(r,i.outPoint))}distanceMultipointGeometry(e,t,n,i){switch(t.getGeometryType()){case c.enumPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distancePointMultipoint(t,e,i,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case c.enumMultiPoint:return this.distanceMultipointMultipoint(e,t,n,i,1,1);case c.enumPolyline:case c.enumPolygon:return this.distanceMultipointMultipath(e,t,n,i);case c.enumEnvelope:return this.distanceMultipointMultipath(e,O(t),n,i);default:return Number.NaN}}distanceMultipointMultipoint(e,t,n,i,r,s){const m={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&r===1&&s===1){const q=Math.trunc(A(Math.sqrt(e.getPointCount())+1,1,T())),I=Math.trunc(A(Math.sqrt(t.getPointCount())+1,1,T()));if((q>=4||I>=4)&&this.distanceMultipointMultipoint(e,t,n,i,q,I)<=this.m_maxSqrDistance)return 0}let o=this.m_maxSqrDistance;const u=[e],y=[t],_=this.swapGeometriesIfBGtA(u,y);_&&(this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s=v(r,r=s),F(n,i)),H(m,z(()=>{F(n,i),this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!_),!1);const h=u[0].getImpl(),p=y[0].getImpl(),x=h.getPointCount(),g=p.getPointCount(),M=g>1;let d=!1;const f=new P,D=new P;for(let q=0;q<x;q+=r){if(h.queryXY(q,f),M){const I=this.m_env2DgeometryB.sqrDistance(f);if(this.m_bIsNearCalc){if(I>o)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(f)<=o)return 0}else if(I>=o)continue}for(let I=0;I<g;I+=s){p.queryXY(I,D);const N=P.sqrDistance(f,D);if(this.m_bIsNearCalc){if(N<=o)return 0}else if(!(N>o||d&&N===o)&&(!d||N<o)&&(l(n,f,q,0),l(i,D,I,0),d=!0,o=N,o===0))return d?Math.sqrt(o):Number.POSITIVE_INFINITY}}return d?Math.sqrt(o):Number.POSITIVE_INFINITY}catch(o){m.error=o,m.hasError=!0}finally{J(m)}}distanceMultipointMultipath(e,t,n,i){let r=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&t.getGeometryType()===c.enumPolygon;const s=t.querySegmentIterator();s.stripAttributes();const m=new E,o=new P;let u=this.m_maxSqrDistance;const y=e.getImpl(),_=y.getPointCount(),h=_>1;let p=!1;for(;s.nextPath();)for(;s.hasNextSegment();){const x=s.nextSegment();if(x.queryLooseEnvelope(m),h){const g=m.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(g>u)continue}else if(g>u||p&&g===u)continue}for(let g=0;g<_;g++){if(y.queryXY(g,o),r&&w(t,o,0)!==0)return l(n,o,-1,Number.NaN),l(i,o,g,0),0;{const D=m.sqrDistance(o);if(this.m_bIsNearCalc){if(D>u)continue}else if(D>u)continue}const M=x.getClosestCoordinate(o,!1),d=x.getCoord2D(M);o.subThis(d);const f=o.sqrLength();if(this.m_bIsNearCalc){if(f<=u)return 0}else if(!(f>u)&&(!p||f<u)&&(u=f,l(n,y.getXY(g),g,0),l(i,d,s.getStartPointIndex(),M),p=!0,u===0))return 0}r=!1}return p?Math.sqrt(u):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(e,t,n,i){switch(t.getGeometryType()){case c.enumPoint:return this.distancePointEnvelope(t,e,i,n);case c.enumMultiPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distanceMultipointMultipath(t,O(e),i,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case c.enumPolyline:case c.enumPolygon:return this.distanceMultipathMultipath(O(e),t,n,i);case c.enumEnvelope:return this.distanceEnvelopeEnvelope(e,t,n,i);default:return Number.NaN}}distanceEnvelopeEnvelope(e,t,n,i){n.t=Number.NaN,n.index=-1,i.t=Number.NaN,i.index=-1;const r=e.asEnvelope2D(),s=t.asEnvelope2D();return Math.sqrt(r.sqrDistanceEnvelope(s,n.outPoint,i.outPoint))}distanceMultipathGeometry(e,t,n,i){switch(t.getGeometryType()){case c.enumPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distancePointMultipath(t,e,i,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case c.enumMultiPoint:{this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const r=this.distanceMultipointMultipath(t,e,i,n);return this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),r}case c.enumPolyline:case c.enumPolygon:return this.distanceMultipathMultipath(e,t,n,i);case c.enumEnvelope:return this.distanceMultipathMultipath(e,O(t),n,i);default:return Number.NaN}}distanceMultipathMultipath(e,t,n,i){const r={stack:[],error:void 0,hasError:!1};try{const s=[e],m=[t],o=this.swapGeometriesIfAGtB(s,m);o&&(this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),F(n,i)),H(r,z(()=>{F(n,i),this.m_env2DgeometryB=v(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!o),!1);const u=s[0],y=m[0],_=u.querySegmentIterator();_.stripAttributes();const h=y.querySegmentIterator();if(h.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const N=Math.trunc(A(Math.sqrt(u.getPointCount())+1,1,T())),B=Math.trunc(A(Math.sqrt(u.getPointCount())+1,1,T()));if(this.distanceMultipointMultipoint(u,y,n,i,N,B)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const N=j(),B=j();if(ue(u,y,_,h,N,B))return S(n,N),S(i,B),0}const p=ce(u),x=[],g=new re,M=new E,d=new E,f=new E;let D=this.m_maxSqrDistance,q=!0,I=!1;for(let N=0,B=p.length;N<B;++N){u.querySegment(p[N],g,!0);const X=g.get();if(X.queryEnvelope(M),!(M.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>D)){if(this.m_bIsNearCalc&&M.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=D)return 0;for(;h.nextPath();){if(this.progress_(),q)y.queryPathEnvelope(h.getPathIndex(),f),x[h.getPathIndex()]=f.clone();else if(M.sqrDistanceEnvelope(x[h.getPathIndex()],null,null)>D)continue;for(;h.hasNextSegment();){const V=h.nextSegment();if(V.queryEnvelope(d),M.sqrDistanceEnvelope(d,null,null)<=D){const ne=!M.isIntersecting(d),L=[0],k=[0];let b=X.distance(V,ne,L,k);if(b*=b,this.m_bIsNearCalc&&b<=this.m_maxSqrDistance)return 0;if(b<D||b===D&&p[N]<n.index){if(I=!0,W(n,X,p[N],L[0]),W(i,V,h.getStartPointIndex(),k[0]),b===0)return 0;D=b}}}}h.resetToFirstPath(),q=!1}}return I?Math.sqrt(D):Number.POSITIVE_INFINITY}catch(s){r.error=s,r.hasError=!0}finally{J(r)}}swapGeometriesIfAGtB(e,t){return R(e[0])>R(t[0])&&(t[0]=v(e[0],e[0]=t[0]),!0)}swapGeometriesIfBGtA(e,t){return this.swapGeometriesIfAGtB(t,e)}}class le{getOperatorType(){return 10100}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}execute(e,t,n){return this.executeEx(e,t,n,null,null,Number.NaN)}executeEx(e,t,n,i,r,s){if(e.isEmpty()||t.isEmpty())return Number.NaN;U(e),U(t);const m=e,o=t;Number.isNaN(s)&&(s=Number.POSITIVE_INFINITY);const u=new he(s,n).calculate(m,o,i,r);return Number.isFinite(u)?u:Number.NaN}}const $=new le;function ee(a,e,t={}){const{unit:n}=t;let i=$.execute(Q(a),Q(e),null);if(i&&n){const r=ae(a);i=se(i,r,n)}return i}const te=$.supportsCurves(),ge=Object.freeze(Object.defineProperty({__proto__:null,execute:ee,supportsCurves:te},Symbol.toStringTag,{value:"Module"})),ye=Object.freeze(Object.defineProperty({__proto__:null,execute:ee,supportsCurves:te},Symbol.toStringTag,{value:"Module"}));export{ye as d,ge as i};
