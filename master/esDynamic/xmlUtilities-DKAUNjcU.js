import{x as y,z as g,K as Z,G as He,O as le,n as Y,bq as ce,bC as W,bz as U,s as j,a2 as ue,M as he,a as Ce,bO as De,bt as ze,bi as Be,D as Ne,bR as Oe}from"./main-BC8gbEPx.js";import{y as me}from"./commonProperties-Bzkkp1tE.js";import{g as de,N as Me,i as Ee,a as We,p as fe,f as Le,d as pe,w as Ge,v as qe,h as Ae}from"./multidimensionalUtils-Cp9Fyxq1.js";import{c as je,w as ye,l as Ve,p as Ue,a as $e,g as Qe,e as xe,W as ge,z as Ke,L as Xe,U as Ze,E as Ye,q as Re,t as et}from"./ImageHistogramParameters-DPaHGAKB.js";import{j as tt,n as it,a as nt,m as rt,_ as st}from"./RasterSymbolizer-D6hosp06.js";import{z as Q,p as at}from"./TileInfo-DcHqeHqG.js";import{QueueProcessor as ot}from"./QueueProcessor-buPyW8Di.js";import{i as be,m as Ie,h as we,x as lt,s as ct}from"./RawBlockCache-Cq3Pc2nz.js";import{U as ee,D as Se,R as ut,u as ht,l as mt,a as dt,f as ft,s as pt}from"./dataUtils-DwTUUyvb.js";import{t as K,j as te,B as ve,m as _e,u as yt,o as ie,V as X,a as xt,r as gt,z as Rt,Z as ne}from"./rasterProjectionHelper-7n7CHYkF.js";import{h as re,l as bt,T as It}from"./rasterFunctionHelper-DnZaz54a.js";import{d as wt}from"./FeatureSet-DagJuGrs.js";const Fe=8,St=256;let vt=0,w=class extends He{constructor(){super(...arguments),this._tileFetchQueue=new ot({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Q.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=K(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){this._set("rasterJobHandler",t),this.datasetFormat==="Function"&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+vt++}set url(t){this._set("url",le(t,Y.getLogger(this)))}async open(t){return this._openPromise??=te().then(()=>this._open(t)),this._openPromise}async fetchTile(t,i,r,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,a=this.getTileExtentFromTileInfo(t,i,r,n);return e={noClip:!0,...e},this.fetchPixels(a,n.size[0],n.size[1],e)}async identify(t,i={}){t=ce(W,t).clone().normalize();const{multidimensionalDefinition:r,timeExtent:e}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:s}=n;let{transposedVariableName:o}=i;const l=s!=null&&a&&(e!=null||de(r));l&&!o&&(o=r!=null&&r.length>0?r[0].variableName??void 0:s.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:h}=n,{datumTransformation:m}=i;let u=ve(t,c,m);if(!h.intersects(u))return{location:u,value:null};if(n.transform!=null){const P=n.transform.inverseTransform(u);if(!n.nativeExtent.intersects(P))return{location:P,value:null};u=P}let f=0;const p=o!=null&&s!=null&&n.hasMultidimensionalTranspose;if(this.datasetFormat==="Function"){const P=this.primaryRasters.rasters[0];if(p)return P.identify(u,i);const{pixelSize:q}=n,S=3,k=q.x*S/2,v=q.y*S/2,J=new U({xmin:u.x-k,xmax:u.x+k,ymin:u.y-v,ymax:u.y+v,spatialReference:c}),C={interpolation:"nearest",multidimensionalDefinition:r,sliceId:i.sliceId},{pixelBlock:D}=await P.fetchPixels(J,S,S,C),{pixelBlock:_}=await this.fetchPixels(J,S,S,C);if(D==null)return{location:u,value:null};const F=Math.floor(S*S*.5),E=!D.mask||D.mask[F]?D.pixels.map(H=>H[F]):null;let A;return _!=null&&(A=!_.mask||_.mask[F]?_.pixels.map(H=>H[F]):void 0),{location:u,value:E,processedValue:A,pyramidLevel:0}}if(!p){if(i.srcResolution)f=_e(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(f=await this.computeBestPyramidLevelForLocation(t,i),f==null)return{location:u,value:null}}const b=this.identifyPixelLocation(u,f,null,p);if(b===null)return{location:u,value:null};const{row:x,col:d,rowOffset:I,colOffset:R,blockWidth:T}=b,L=o??i.sliceId,z=be(this.rasterId,L),B=`${f}/${x}/${d}`;let N=Ie(z,null,B);N==null&&(N=this.fetchRawTile(f,x,d,i),we(z,null,B,N));const O=await N;if(!O?.pixels?.length)return{location:u,value:null};const M=I*T+R;return this._processIdentifyResult(O,{srcLocation:u,position:M,pyramidLevel:f,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(t,i,r,e={}){t=yt(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(t,i,r,e);const a=K(t.spatialReference),s=ie(t);if(a==null||s===0||s===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(t,i,r,e);if(s>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:l,xmax:c}=t,h=Math.round(a/(c-l)*i),m=h-Math.round((a/2-l)/(c-l)*i);let u=0;const f=[];for(let d=0;d<=s;d++){const I=new U({xmin:d===0?l:-a/2,xmax:d===s?c-a*d:a/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),R=d===0?h-m:d===s?i-u:h;u+=R,f.push(R);const T=e.disableWrapAround&&d>0?null:this._fetchPixels(I,R,r,e);o.push(T)}const p=(await Promise.all(o)).map(d=>d?.pixelBlock);let b=null;const x={width:i,height:r};return this.rasterJobHandler?b=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},e)).pixelBlock:b=ee(p,x,{blockWidths:f}),{extent:t,srcExtent:X(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:b}}async fetchRawPixels(t,i,r,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(t,i,r,e),{nativeExtent:a,nativePixelSize:s,storageInfo:o}=this.rasterInfo,l=2**t,c=s.x*l,h=s.y*l,m=new U({xmin:a.xmin+c*i.x,xmax:a.xmin+c*(i.x+r.width-1),ymin:a.ymax-h*(i.y+r.height-1),ymax:a.ymax-h*i.y,spatialReference:a.spatialReference});if(!n)return{extent:m,srcExtent:m,pixelBlock:null};const{pixelBlocks:u,mosaicSize:f}=n;if(u.length===1&&u[0]!=null&&u[0].width===r.width&&u[0].height===r.height)return{extent:m,srcExtent:m,pixelBlock:n.pixelBlocks[0]};const p=t>0?o.pyramidBlockWidth:o.blockWidth,b=t>0?o.pyramidBlockHeight:o.blockHeight,x={x:i.x%p,y:i.y%b};let d;return this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:f,destDimension:r,clipOffset:x,clipSize:r,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:d=ee(u,f,{clipOffset:x,clipSize:r}),{extent:m,srcExtent:m,pixelBlock:d}}fetchRawTile(t,i,r,e){throw new j("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return X(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?tt(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,r=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:a,headers:s}=i;r=r??i.retryCount??this.ioConfig.retryCount;const o=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await ue(t,{...i,query:{...a,...e},headers:{...s,...o}})}catch(l){if(r>0)return r--,this.request(t,i,r);throw l}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:Me(t,i)}getTileExtentFromTileInfo(t,i,r,e){const n=e.lodAt(t);return this.getTileExtent({x:n.resolution,y:n.resolution},i,r,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:r,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=t;if(!t.tileInfo){const a=[],s=t.maximumPyramidLevel||0;let o=(e.x+e.y)/2,l=1/.0254*96*o;for(let h=0;h<=s&&(a.unshift(new at({level:s-h,resolution:o,scale:l})),h!==s);h++)if(n){const m=(n[h].x+n[h].y)/2;l*=m/o,o=m}else o*=2,l*=2;const c=new W({x:r.xmin,y:r.ymax,spatialReference:i});t.tileInfo=new Q({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:a}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,r=512,e){const{width:n,height:a,nativeExtent:s,pixelSize:o,spatialReference:l}=t,c=new W({x:s.xmin,y:s.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,a))/Math.LN2-8)));const h=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[o],e);t.storageInfo=new it({blockWidth:i,blockHeight:r,pyramidBlockWidth:i,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:h})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,r,e,n,a=0,s=2){if(n.length===1&&a>0){n=[...n];let{x:h,y:m}=n[0];for(let u=0;u<a;u++)h*=s,m*=s,n.push({x:h,y:m})}const o=[],{x:l,y:c}=e;for(let h=0;h<n.length;h++){const{x:m,y:u}=n[h];o.push({minCol:Math.floor((t.xmin-l+.1*m)/i/m),maxCol:Math.floor((t.xmax-l-.1*m)/i/m),minRow:Math.floor((c-t.ymax+.1*u)/r/u),maxRow:Math.floor((c-t.ymin-.1*u)/r/u)})}return o}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(r!=null&&r.length)return r[t-1];const n=e**t;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(t,i,r,e){const{spatialReference:n,nativeExtent:a,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=s,h=e&&c!=null?c.tileSize[0]:s.blockWidth,m=e&&c!=null?c.tileSize[1]:s.blockHeight,u=ve(t,n,r);if(!a.intersects(u)||i<0||i>o)return null;const f=this.getPyramidPixelSize(i),{x:p,y:b}=f,x=(l.y-u.y)/b/m,d=(u.x-l.x)/p/h,I=Math.min(m-1,Math.floor((x-Math.floor(x))*m)),R=Math.min(h-1,Math.floor((d-Math.floor(d))*h));return{pyramidLevel:i,row:Math.floor(x),col:Math.floor(d),rowOffset:I,colOffset:R,blockWidth:h,srcLocation:u}}getTileExtent(t,i,r,e,n,a){const[s,o]=a,l=e.x+r*s*t.x,c=l+s*t.x,h=e.y-i*o*t.y,m=h-o*t.y;return new U({xmin:l,xmax:c,ymin:m,ymax:h,spatialReference:n})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,r){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<r||e.minRow>i||e.minCol>r}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:r,height:e}=t,n=he.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new U({xmin:-.5,ymax:.5,xmax:r-.5,ymin:.5-e,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new W({x:1,y:1,spatialReference:n});const{extent:a,storageInfo:s}=t;if(s){s.origin=new W({x:a.xmin,y:a.ymax,spatialReference:n});const{pyramidResolutions:o,tileInfo:l}=s;if(o&&o.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=s.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((h,m)=>{h.resolution=c*2**m,h.scale=96*h.resolution/.0254})}}}async _fetchPixels(t,i,r,e={}){let n=ie(t);if(n>=2)return{extent:t,pixelBlock:null};const a=this._getSourceDataInfo(t,i,r,e),{pyramidLevel:s,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:h,ul:m}=a;if(c===0||h===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:u}=this,f=u.transform,p=f?.type==="gcs-shift",b=K(t.spatialReference)!=null;!p&&b||(n=ie(a.srcExtent,p));const x=await this._fetchRawTiles(s,m,{width:c,height:h,wrapCount:n},e);if(!x)return{extent:t,srcExtent:l,pixelBlock:null};const d=u.storageInfo,I=s>0?d.pyramidBlockWidth:d.blockWidth,R=s>0?d.pyramidBlockHeight:d.blockHeight;let{x:T,y:L}=u.pixelSize;if(s>0){const{pyramidResolutions:G,pyramidScalingFactor:Je}=d;if(G!=null&&G[s-1])({x:T,y:L}=G[s-1]);else{const oe=Je**s;T*=oe,L*=oe}}const z=u.spatialReference,B=new W({x:T,y:L,spatialReference:z}),N=I===c&&R===h&&m.x%I==0&&m.y%R==0,O=new W({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference}),M=!t.spatialReference.equals(z),P=z.isGeographic?1e-9:1e-4,{datumTransformation:q}=e;if(!M&&N&&x.pixelBlocks.length===1&&I===i&&R===r&&_t(o,O,P))return{extent:t,srcExtent:l,srcTilePixelSize:B,pixelBlock:x.pixelBlocks[0]};const S=b&&K(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,k=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");k&&!this.rasterJobHandler&&await te();const v=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:O.toJSON(),datumTransformation:q,rasterTransform:f,hasWrapAround:n>0||S,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:k},e):xt({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:O,datumTransformation:q,rasterTransform:f,hasWrapAround:n>0||S,isAdaptive:!1,includeGCSGrid:k});let J;const C=!e.requestRawData,D={rows:v.spacing[0],cols:v.spacing[1]},_=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,x.extent.xmin):void 0,{pixelBlocks:F,mosaicSize:E,isPartiallyFilled:A}=x;let H=null;if(this.rasterJobHandler)({pixelBlock:J,localNorthDirections:H}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:F,srcMosaicSize:E,destDimension:C?{width:i,height:r}:null,coefs:C?v.coefficients:null,sampleSpacing:C?D:null,projectDirections:k,gcsGrid:k?v.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:_,blockWidths:null},e));else{const G=ee(F,E,{alignmentInfo:_});J=C?Se(G,{width:i,height:r},v.coefficients,D,e.interpolation):G,k&&v.gcsGrid&&(H=ut({width:i,height:r},v.gcsGrid),J=ht(J,this.rasterInfo.dataType,H))}return e.requestRawData||k?{extent:t,srcExtent:l,srcTilePixelSize:B,pixelBlock:J,transformGrid:v,localNorthDirections:H,isPartiallyFilled:A}:{extent:t,srcExtent:l,srcTilePixelSize:B,pixelBlock:J}}async _fetchRawTiles(t,i,r,e){const{origin:n,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:o}=this.getBlockWidthHeight(t);let{x:l,y:c}=i,{width:h,height:m,wrapCount:u}=r;const f=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,h+=2*e.buffer.cols,m+=2*e.buffer.rows);let p=0,b=0,x=0;u&&f!=null&&({worldColumnCountFromOrigin:b,originColumnOffset:x,rightPadding:p}=f,b*f.blockWidth-p>=l+h&&(p=0));const d=Math.floor(l/s),I=Math.floor(c/o),R=Math.floor((l+h+p-1)/s),T=Math.floor((c+m+p-1)/o),L=a[t];if(!L)return null;const{minRow:z,minCol:B,maxCol:N,maxRow:O}=L;if(u===0&&(T<z||R<B||I>O||d>N))return null;const M=new Array;let P=!1;const q=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let _=I;_<=T;_++)for(let F=d;F<=R;F++){let E=F;if(!e.disableWrapAround&&u&&f!=null&&b<=F&&(E=F-b-x),_>=z&&E>=B&&O>=_&&N>=E){const A=this._tileFetchQueue.push({pyramidLevel:t,row:_,col:E,options:e},{signal:e.signal});q?M.push(new Promise(H=>{A.then(G=>H(G)).catch(()=>{P=!0,H(null)})})):M.push(A)}else M.push(Promise.resolve(null))}if(M.length===0)return null;const S=await Promise.all(M),k={height:(T-I+1)*o,width:(R-d+1)*s},{spatialReference:v}=this.rasterInfo,J=this.getPyramidPixelSize(t),{x:C,y:D}=J;return{extent:new U({xmin:n.x+d*s*C,xmax:n.x+(R+1)*s*C,ymin:n.y-(T+1)*o*D,ymax:n.y-I*o*D,spatialReference:v}),pixelBlocks:S,mosaicSize:k,isPartiallyFilled:P}}_fetchRawTile(t,i,r,e){const n=this.rasterInfo.storageInfo.blockBoundary[t];if(!n)return Promise.resolve(null);const{minRow:a,minCol:s,maxCol:o,maxRow:l}=n;if(i<a||r<s||i>l||r>o)return Promise.resolve(null);const c=be(this.rasterId,e.sliceId),h=`${t}/${i}/${r}`;let m=Ie(c,e.registryId,h);if(m==null){const u=new AbortController;m=this.fetchRawTile(t,i,r,{...e,signal:u.signal}),we(c,e.registryId,h,m,u),m.catch(()=>lt(c,e.registryId,h))}return e.signal&&Ce(e,()=>{ct(c,e.registryId,h)}),m}_computeMagDirValues(t){const{bandCount:i,dataType:r}=this.rasterInfo;if(!(i===2&&r==="vector-magdir"||r==="vector-uv")||t?.length!==2||!t[0]?.length)return null;const e=t[0].length;if(r==="vector-magdir"){const l=t[1].map(c=>(c+360)%360);return[t[0],l]}const[n,a]=t,s=[],o=[];for(let l=0;l<e;l++){const[c,h]=mt([n[l],a[l]]);s.push(c),o.push(h)}return[s,o]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=gt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,r,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,n));const a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:o,pyramidLevel:l}=n,c=s/i,h=o/r,m=l<a&&c*h>=16,u=l===a&&this._requireTooManySrcTiles(s,o,i,r);if(m||u||s===0||o===0){const f=new W({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference});let p=Rt(f,this.rasterInfo.spatialReference,t,n.datumTransformation);const b=!p||e.srcResolution&&p.x+p.y<e.srcResolution.x+e.srcResolution.y;if(m&&e.srcResolution&&b){const x=Math.round(Math.log(Math.max(c,h))/Math.LN2)-1;if(a-l+3>=x){const d=2**x;p={x:e.srcResolution.x*d,y:e.srcResolution.y*d}}}p&&(n.srcResolution=p,this._updateSourceDataInfo(t,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,r)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(t,i,r,e){const{tileInfo:n}=this.rasterInfo.storageInfo,a=Math.ceil(t/n.size[0])*Math.ceil(i/n.size[1]),s=t/r,o=i/e,l=Math.max(1,(r+e)/1024);return a>=St*l||s>Fe||o>Fe}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:r}=this,e=r.spatialReference,{srcResolution:n,datumTransformation:a}=i,{pyramidLevel:s,pyramidResolution:o,excessiveReading:l}=_e(n,r,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||X(t,e,a);if(c==null)return;const h=r.transform;h&&(c=h.inverseTransform(c)),i.srcExtent=c;const{x:m,y:u}=r.storageInfo.origin,f=Math.floor((c.xmin-m)/o.x+.1),p=Math.floor((u-c.ymax)/o.y+.1),b=Math.floor((c.xmax-m)/o.x-.1),x=Math.floor((u-c.ymin)/o.y-.1),d=c.width<.1*o.x?0:b-f+1,I=c.height<.1*o.y?0:x-p+1;i.pyramidLevel=s,i.pyramidResolution=o,i.srcWidth=d,i.srcHeight=I,i.ul={x:f,y:p}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:r,position:e,pyramidLevel:n,useTransposedTile:a}=i,s=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:r,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!a){const x=t.pixels.map(R=>R[e]),d={location:r,value:x,pyramidLevel:n},I=this._computeMagDirValues(x.map(R=>[R]));return I?.length&&(d.magdirValue=I.map(R=>R[0])),d}let l=t.pixels.map(x=>x.slice(e*s,e*s+s)),c=this._computeMagDirValues(l);const{requestSomeSlices:h,identifyOptions:m}=i;let u=Ee(o,m.transposedVariableName);if(h){const x=We(u,m.multidimensionalDefinition,m.timeExtent);l=l.map(d=>x.map(I=>d[I])),c=c?.map(d=>x.map(I=>d[I])),u=x.map(d=>u[d])}const f=t.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:t.pixelType};let b;return f!=null&&(dt(p,f),b=p.mask),{location:r,value:null,dataSeries:u.map((x,d)=>{const I={value:b?.[d]===0?null:l.map(R=>R[d]),multidimensionalDefinition:x.multidimensionalDefinition.map(R=>new fe({...R,isSlice:!0}))};return c?.length&&(I.magdirValue=[c[0][d],c[1][d]]),I}),pyramidLevel:n}}};function _t(t,i,r){return Math.abs(t.x-i.x)<r&&Math.abs(t.y-i.y)<r}y([g()],w.prototype,"_rasterTileAlignmentInfo",void 0),y([g()],w.prototype,"_tileFetchQueue",void 0),y([g({readOnly:!0})],w.prototype,"_isGlobalWrappableSource",null),y([g({readOnly:!0})],w.prototype,"_hasNoneOrGCSShiftTransform",null),y([g()],w.prototype,"_openPromise",void 0),y([g()],w.prototype,"rasterJobHandler",null),y([g({readOnly:!0})],w.prototype,"rasterId",null),y([g(me)],w.prototype,"url",null),y([g({type:String,json:{write:!0}})],w.prototype,"datasetName",void 0),y([g({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),y([g()],w.prototype,"hasUniqueSourceStorageInfo",void 0),y([g()],w.prototype,"rasterInfo",void 0),y([g()],w.prototype,"ioConfig",void 0),y([g()],w.prototype,"sourceJSON",void 0),w=y([Z("esri.layers.support.rasterDatasets.BaseRaster")],w);const Te=w,Ft=40;let V=class extends Te{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,r,e={}){const{rasters:n,rasterIds:a}=this.primaryRasters;let s=!1;const{interpolation:o}=e,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!e.requestRawData&&l&&(s=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:s});const c=n.map(R=>R.fetchPixels(t,i,r,e)),h=await Promise.all(c),m=h.map(R=>R.pixelBlock),u=s||e.requestRawData?h.map(R=>R.srcTilePixelSize):null;if(e.skipRasterFunction||m.every(R=>R==null))return h[0];const f=h.find(R=>R.pixelBlock!=null)?.extent??t;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:f,primaryPixelBlocks:m,primaryPixelSizes:u,primaryRasterIds:a}):this.rasterFunction.process({extent:f,primaryPixelBlocks:m,primaryPixelSizes:u,primaryRasterIds:a});const{transformGrid:b}=h[0];if(!s||p==null||b==null){const R=e.noClip?null:this.getClippingGeometry(f.spatialReference);return e.noClip||e.requestRawData||p==null||!R||(p=await re(p,f,R)),{...h[0],pixelBlock:p}}const x={rows:b.spacing[0],cols:b.spacing[1]};let d;this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:i,height:r},coefs:b.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:d=Se(p,{width:i,height:r},b.coefficients,x,o);const I=e.noClip?null:this.getClippingGeometry(t.spatialReference);return e.noClip||e.requestRawData||d==null||I==null||(d=await re(d,t,I)),{extent:t,srcExtent:h[0].srcExtent,pixelBlock:d}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const r=kt(t);let e=this._clippingGeometry.get(r);return e!=null||(e=t.equals(i.spatialReference)?i:ne(i,t),this._clippingGeometry.set(r,e)),e}async _open(t){const{rasterFunction:i}=this;this.primaryRasters?.rasters?.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(c=>c.rasterJobHandler=this.rasterJobHandler));const{rasters:r,rasterIds:e}=this.primaryRasters,n=r.map(c=>c.rasterInfo?void 0:c.open(t));await Promise.all(n);const a=r.map(({rasterInfo:c})=>c),s=i.bind({rasterInfos:a,rasterIds:e});if(i.rawSourceRasterInfos=a,!s.success||a.length===0)throw new j("raster-function:open",`cannot bind the function: ${s.error??""}`);const o=i.functionName==="Table"?i:i.functionArguments?.raster;o?.functionName==="Table"&&(i.rasterInfo.attributeTable=wt.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=a[0];this.hasUniqueSourceStorageInfo=a.length===1||a.slice(1).every(c=>Tt(c,l)),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t?.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:r}=this.rasterInfo,{difference:e,densify:n}=await import("./geometryEngine-BhiInAau.js");let a=n(De.fromExtent(r),2*(r.width+r.height)/Ft);a=ne(a,i.spatialReference),i=e(a,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};y([g({type:String,json:{write:!0}})],V.prototype,"datasetFormat",void 0),y([g()],V.prototype,"tileType",void 0),y([g()],V.prototype,"rasterFunction",void 0),y([g()],V.prototype,"primaryRasters",void 0),V=y([Z("esri.layers.support.rasterDatasets.FunctionRaster")],V);const ke=V;function Tt(t,i){const{storageInfo:r,pixelSize:e,spatialReference:n,extent:a}=t,{storageInfo:s,pixelSize:o,spatialReference:l,extent:c}=i;return e.x===o.x&&e.y===o.y&&n.equals(l)&&a.equals(c)&&r.blockHeight===s.blockHeight&&r.blockWidth===s.blockWidth&&r.maximumPyramidLevel===s.maximumPyramidLevel}function kt(t){return String(t.wkid??t.wkt??t.wkt2)}const Pt=t=>{let i=class extends t{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=e[0]?.raster?.datasetFormat==="Function"}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",le(e,Y.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;return e?n?.find(({name:a})=>a===e)?.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,a){const s=n?.layerDefinition?.drawingInfo?.renderer;return $e(s,a)||void 0}async convertVectorFieldData(e,n){const{serviceRasterInfo:a}=this;if(e==null||!a)return null;const s=this._rasterJobHandler.instance,o=a.dataType;return s?s.convertVectorFieldData({pixelBlock:e,dataType:o},n):ft(e,o)}async computeStatisticsHistograms(e,n){await this.load(n),e=ce(Qe,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:s}=e;if(s==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=s;const{spatialReference:l}=a;s.spatialReference.equals(l)||(await te(),o=s.type==="extent"?X(s,l):ne(s,l));const c=e.pixelSize??new W({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:l}),{extent:h,width:m,height:u}=bt(a,o,c),f=await this.fetchPixels(h,m,u,{...n,interpolation:"nearest"});if(f.pixelBlock==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const p=await re(f.pixelBlock,h,o),b=this._rasterJobHandler.instance;return b?b.computeStatisticsHistograms({pixelBlock:p},n):rt(p)}async createFlowMesh(e,n){const a=this._rasterJobHandler.instance;return a?a.createFlowMesh(e,n):pt(e.meshType,e.simulationSettings,e.flowData,n.signal!=null?n.signal:new AbortController().signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const a=Le({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n}=this;if(!e||!n||!this.renderer)return;const{rasterInfo:a}=this.raster,s=pe(a,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=s?.name,l=xe({...this.renderer.toJSON(),variableName:o});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(l))return;const c=this._rasterJobHandler.instance;c&&(n.rasterInfo=ge(a,o),n.rendererJSON=l,n.bind(),await c.updateSymbolizer(n),this._cachedRendererJson=l)}async applyRenderer(e,n){const a=e?.pixelBlock;if(!(a!=null&&a.pixels&&a.pixels.length>0))return null;let s;await this.updateRenderer();const o=this._rasterJobHandler.instance,l=this.bandIds??[];return s=o?await o.symbolize({...e,simpleStretchParams:n,bandIds:l}):this.symbolizer.symbolize({...e,simpleStretchParams:n,bandIds:l}),s}getTileUrl(e,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${a}`:""}getCompatibleTileInfo(e,n,a=!1){if(!this.loaded||n==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const s=Oe(e);return Q.create({size:256,spatialReference:e,origin:s?{x:s.origin[0],y:s.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,a,s={}){if(r(this),s.requestAsImageElement){const l=this.getTileUrl(e,n,a);return ue(l,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then(c=>c.data)}const{serviceRasterInfo:o}=this;if(o.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null){const l=s.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,a,l),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,a,s)}async fetchPixels(e,n,a,s={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a),this.raster.fetchPixels(e,n,a,s))}async identify(e,n={}){await this.load();const{raster:a,serviceRasterInfo:s}=this;if(s?.multidimensionalInfo!=null&&!(s.hasMultidimensionalTranspose&&(de(n.multidimensionalDefinition)||n.transposedVariableName||n.timeExtent))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const o=this.multidimensionalSubset?.areaOfInterest;if(o&&!o.contains(e))throw new j("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return a.identify(e,n)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=n?.[0]?.variableName;return e.variables.some(s=>s.name===a&&(!n?.[0].dimensionName||s.dimensions.some(o=>o.name==="StdTime")))}getStandardTimeValue(e){return new Date(Ge(e)).toISOString()}getMultidimensionalSubsetVariables(e){const n=e??this.serviceRasterInfo?.multidimensionalInfo;return qe(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Ae(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&this.raster.datasetFormat==="Function"&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const e=new et;return this._rasterJobHandler.connectionPromise=e.initialize().then(async()=>{r(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(this.interpolation==null){r(this);const{raster:e}=this,n=Ke(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",n)}}_configDefaultRenderer(e="no"){r(this);const{rasterInfo:n}=this.raster,a=pe(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),s=a?.name,o=Xe({variableName:s,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=o?.bandIds??Ze(n)),!this.renderer||e==="override"){const m=Ye(this.raster),u=o?.renderer??Re(n,{bandIds:this.bandIds,variableName:s,rasterFunctionColorRamp:m}),f=n.statistics,p=f&&f.length>0?f[0]:null,b=p?.max??0,x=p?.min??0;this.raster.datasetFormat==="WCSServer"&&u.type==="raster-stretch"&&(b>1e24||x<-1e24)&&(u.dynamicRangeAdjustment=!0,u.customStatistics=null,u.stretchType==="none"&&(u.stretchType="min-max")),this.renderer=u}const l=xe({...this.renderer.toJSON(),variableName:s}),c=ge(n,s);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new st({rendererJSON:l,rasterInfo:c});const h=this.symbolizer.bind();if(h.success){if(e==="auto"){const{colormap:m}=this.raster.rasterInfo,u=this.renderer;if(m!=null&&u.type==="raster-colormap"){const f=Re(this.raster.rasterInfo);JSON.stringify(f)!==JSON.stringify(u)&&this._configDefaultRenderer("override")}else if(u.type==="raster-stretch"){const f=this.bandIds?.length,p=u.customStatistics?.length;!u.dynamicRangeAdjustment&&p&&f&&p!==f&&this._configDefaultRenderer("override")}}}else Y.getLogger(this).warn("imagery-tile-mixin",h.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&this.raster.datasetFormat==="Function"){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",ye.fromJSON(h)))}let e,n=this.raster,a=!1;n.datasetFormat==="Function"?(e=n.primaryRasters.rasters,n=e[0],a=!0):e=[n];const{rasterFunction:s}=this;if(s){const h={raster:n};e.length>1&&e.forEach(f=>h[f.url]=f);const m=It(s.functionDefinition?.toJSON()??s.toJSON(),h),u=new ke({rasterFunction:m});u.rasterJobHandler=this._rasterJobHandler.instance,await u.open(),this.raster=u}else this.raster=n,await n.open();if(this._cachedRendererJson=null,!a&&!s)return;const{bandIds:o}=this,{bandCount:l}=this.raster.rasterInfo,c=o?.length?o.some(h=>h>=l):l>=3;o&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function r(e){if(!e.raster||!e.serviceRasterInfo)throw new j("imagery-tile","no raster")}return y([g({clonable:!1})],i.prototype,"_cachedRendererJson",void 0),y([g({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),y([g({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),y([g({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),y([g({clonable:!1})],i.prototype,"_rasterJobHandler",void 0),y([g({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),y([g({type:[ze],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),y([g({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),y([g({json:{read:!1}})],i.prototype,"fullExtent",null),y([g({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Be(nt)],i.prototype,"interpolation",void 0),y([g()],i.prototype,"ioConfig",void 0),y([g({type:[fe],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),y([g({type:je,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),y([g()],i.prototype,"raster",void 0),y([g({type:ye})],i.prototype,"rasterFunction",null),y([g()],i.prototype,"serviceRasterInfo",void 0),y([g()],i.prototype,"sourceJSON",void 0),y([g({readOnly:!0,type:he,json:{read:!1}})],i.prototype,"spatialReference",void 0),y([g({type:Q})],i.prototype,"tileInfo",void 0),y([g(me)],i.prototype,"url",null),y([g()],i.prototype,"renderer",null),y([g({types:Ve,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ue,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],i.prototype,"internalRenderer",null),y([Ne("internalRenderer")],i.prototype,"readRenderer",null),y([g({clonable:!1})],i.prototype,"symbolizer",void 0),i=y([Z("esri.layers.mixins.ImageryTileMixin")],i),i};function $(t,i){if(!t||!i)return[];let r=i;i.includes("/")?(r=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=[];if(i){const a=$(t,r);for(let s=0;s<a.length;s++)$(a[s],i).forEach(o=>e.push(o));return e}const n=t.getElementsByTagNameNS("*",r);if(!n||n.length===0)return[];for(let a=0;a<n.length;a++)e.push(n[a]||n.item(a));return e}function se(t,i){if(!t||!i)return null;let r=i;i.includes("/")?(r=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=$(t,r);return e.length>0?i?se(e[0],i):e[0]:null}function ae(t,i=null){const r=i?se(t,i):t;let e;return r?(e=r.textContent||r.nodeValue,e?e.trim():null):null}function Pe(t,i){const r=$(t,i),e=[];let n;for(let a=0;a<r.length;a++)n=r[a].textContent||r[a].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function Jt(t,i=null){return ae(t,i)?.split(" ").map(r=>Number(r))??[]}function Ht(t,i){return Pe(t,i).map(r=>Number(r))}function Ct(t,i){const r=ae(t,i);return Number(r)}function Dt(t,i){const r=t?.nodeName?.toLowerCase(),e=i.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===e}function zt(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{Pt as K,Te as X,ke as a,zt as c,se as e,Dt as i,Pe as l,$ as n,Ct as o,Jt as r,ae as t,Ht as u};
