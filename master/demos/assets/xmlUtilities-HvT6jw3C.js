const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngine-CVDxMhql.js","./main-asQ7SttR.js","./preload-helper-ExcqyqRp.js","./main-DmIi68wH.css","./geometryEngineBase-8g0RzW7z.js","./_commonjsHelpers-DCkdB7M8.js","./hydrated-BabTFx4N.js"])))=>i.map(i=>d[i]);
import{B as y,D as g,N as re,J as ke,T as xe,n as ee,bs as ge,bE as W,bB as V,s as j,a4 as Re,O as be,a as Pe,bR as Je,bv as He,bk as Ce,H as De,bU as Be}from"./main-asQ7SttR.js";import{y as Ie}from"./commonProperties-BAQ0_iGY.js";import{g as we,N as $e,i as ze,a as Ne,p as Se,f as Me,d as ae,w as Oe,v as Ee,h as We}from"./multidimensionalUtils-CiU1wuoV.js";import{c as Le,w as oe,l as Ge,p as qe,a as Ae,g as je,e as le,W as ce,z as Ve,L as Ue,U as Qe,E as Xe,q as ue,t as Ke}from"./ImageHistogramParameters-Cu4-jinR.js";import{j as Ze,n as Ye,a as et,m as tt,_ as it}from"./RasterSymbolizer-IOW6lFnu.js";import{z as X,p as nt}from"./TileInfo-DFofX128.js";import{_ as rt}from"./preload-helper-ExcqyqRp.js";import{QueueProcessor as st}from"./QueueProcessor-CVaNJhFS.js";import{i as he,m as de,h as me,x as at,s as ot}from"./RawBlockCache-DVaSb0cw.js";import{U as Z,D as ve,R as lt,u as ct,l as ut,a as ht,f as dt,s as mt}from"./dataUtils-DJt1u4TY.js";import{t as U,j as te,B as fe,m as pe,u as ft,o as Y,V as Q,a as pt,r as yt,z as xt,Z as ie}from"./rasterProjectionHelper-rgUEkvip.js";import{h as ne,l as gt,T as Rt}from"./rasterFunctionHelper-CgGPDoBU.js";import{d as bt}from"./FeatureSet-BbkVLp0y.js";const ye=8,It=256;let wt=0,w=class extends ke{constructor(){super(...arguments),this._tileFetchQueue=new st({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:X.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=U(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){this._set("rasterJobHandler",t),this.datasetFormat==="Function"&&this.primaryRasters?.rasters?.forEach(i=>i.rasterJobHandler=t)}get rasterId(){return this.url||"rasterId-"+wt++}set url(t){this._set("url",xe(t,ee.getLogger(this)))}async open(t){return this._openPromise??=te().then(()=>this._open(t)),this._openPromise}async fetchTile(t,i,s,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,a=this.getTileExtentFromTileInfo(t,i,s,n);return e={noClip:!0,...e},this.fetchPixels(a,n.size[0],n.size[1],e)}async identify(t,i={}){t=ge(W,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:e}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:a,multidimensionalInfo:r}=n;let{transposedVariableName:o}=i;const l=r!=null&&a&&(e!=null||we(s));l&&!o&&(o=s!=null&&s.length>0?s[0].variableName??void 0:r.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:h}=n,{datumTransformation:d}=i;let u=fe(t,c,d);if(!h.intersects(u))return{location:u,value:null};if(n.transform!=null){const P=n.transform.inverseTransform(u);if(!n.nativeExtent.intersects(P))return{location:P,value:null};u=P}let f=0;const p=o!=null&&r!=null&&n.hasMultidimensionalTranspose;if(this.datasetFormat==="Function"){const P=this.primaryRasters.rasters[0];if(p)return P.identify(u,i);const{pixelSize:G}=n,S=3,k=G.x*S/2,v=G.y*S/2,J=new V({xmin:u.x-k,xmax:u.x+k,ymin:u.y-v,ymax:u.y+v,spatialReference:c}),C={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId},{pixelBlock:D}=await P.fetchPixels(J,S,S,C),{pixelBlock:_}=await this.fetchPixels(J,S,S,C);if(D==null)return{location:u,value:null};const T=Math.floor(S*S*.5),O=!D.mask||D.mask[T]?D.pixels.map(H=>H[T]):null;let q;return _!=null&&(q=!_.mask||_.mask[T]?_.pixels.map(H=>H[T]):void 0),{location:u,value:O,processedValue:q,pyramidLevel:0}}if(!p){if(i.srcResolution)f=pe(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(f=await this.computeBestPyramidLevelForLocation(t,i),f==null)return{location:u,value:null}}const b=this.identifyPixelLocation(u,f,null,p);if(b===null)return{location:u,value:null};const{row:x,col:m,rowOffset:I,colOffset:R,blockWidth:F}=b,L=o??i.sliceId,B=he(this.rasterId,L),$=`${f}/${x}/${m}`;let z=de(B,null,$);z==null&&(z=this.fetchRawTile(f,x,m,i),me(B,null,$,z));const N=await z;if(!N?.pixels?.length)return{location:u,value:null};const M=I*F+R;return this._processIdentifyResult(N,{srcLocation:u,position:M,pyramidLevel:f,useTransposedTile:!!p,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(t,i,s,e={}){t=ft(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(t,i,s,e);const a=U(t.spatialReference),r=Y(t);if(a==null||r===0||r===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(t,i,s,e);if(r>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:l,xmax:c}=t,h=Math.round(a/(c-l)*i),d=h-Math.round((a/2-l)/(c-l)*i);let u=0;const f=[];for(let m=0;m<=r;m++){const I=new V({xmin:m===0?l:-a/2,xmax:m===r?c-a*m:a/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),R=m===0?h-d:m===r?i-u:h;u+=R,f.push(R);const F=e.disableWrapAround&&m>0?null:this._fetchPixels(I,R,s,e);o.push(F)}const p=(await Promise.all(o)).map(m=>m?.pixelBlock);let b=null;const x={width:i,height:s};return this.rasterJobHandler?b=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:f},e)).pixelBlock:b=Z(p,x,{blockWidths:f}),{extent:t,srcExtent:Q(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:b}}async fetchRawPixels(t,i,s,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(t,i,s,e),{nativeExtent:a,nativePixelSize:r,storageInfo:o}=this.rasterInfo,l=2**t,c=r.x*l,h=r.y*l,d=new V({xmin:a.xmin+c*i.x,xmax:a.xmin+c*(i.x+s.width-1),ymin:a.ymax-h*(i.y+s.height-1),ymax:a.ymax-h*i.y,spatialReference:a.spatialReference});if(!n)return{extent:d,srcExtent:d,pixelBlock:null};const{pixelBlocks:u,mosaicSize:f}=n;if(u.length===1&&u[0]!=null&&u[0].width===s.width&&u[0].height===s.height)return{extent:d,srcExtent:d,pixelBlock:n.pixelBlocks[0]};const p=t>0?o.pyramidBlockWidth:o.blockWidth,b=t>0?o.pyramidBlockHeight:o.blockHeight,x={x:i.x%p,y:i.y%b};let m;return this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:f,destDimension:s,clipOffset:x,clipSize:s,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:m=Z(u,f,{clipOffset:x,clipSize:s}),{extent:d,srcExtent:d,pixelBlock:m}}fetchRawTile(t,i,s,e){throw new j("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Q(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?Ze(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,s=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:a,headers:r}=i;s=s??i.retryCount??this.ioConfig.retryCount;const o=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await Re(t,{...i,query:{...a,...e},headers:{...r,...o}})}catch(l){if(s>0)return s--,this.request(t,i,s);throw l}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:$e(t,i)}getTileExtentFromTileInfo(t,i,s,e){const n=e.lodAt(t);return this.getTileExtent({x:n.resolution,y:n.resolution},i,s,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:s,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=t;if(!t.tileInfo){const a=[],r=t.maximumPyramidLevel||0;let o=(e.x+e.y)/2,l=1/.0254*96*o;for(let h=0;h<=r&&(a.unshift(new nt({level:r-h,resolution:o,scale:l})),h!==r);h++)if(n){const d=(n[h].x+n[h].y)/2;l*=d/o,o=d}else o*=2,l*=2;const c=new W({x:s.xmin,y:s.ymax,spatialReference:i});t.tileInfo=new X({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:a}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,s=512,e){const{width:n,height:a,nativeExtent:r,pixelSize:o,spatialReference:l}=t,c=new W({x:r.xmin,y:r.ymax,spatialReference:l});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,a))/Math.LN2-8)));const h=this.computeBlockBoundary(r,512,512,{x:r.xmin,y:r.ymax},[o],e);t.storageInfo=new Ye({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:h})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,s,e,n,a=0,r=2){if(n.length===1&&a>0){n=[...n];let{x:h,y:d}=n[0];for(let u=0;u<a;u++)h*=r,d*=r,n.push({x:h,y:d})}const o=[],{x:l,y:c}=e;for(let h=0;h<n.length;h++){const{x:d,y:u}=n[h];o.push({minCol:Math.floor((t.xmin-l+.1*d)/i/d),maxCol:Math.floor((t.xmax-l-.1*d)/i/d),minRow:Math.floor((c-t.ymax+.1*u)/s/u),maxRow:Math.floor((c-t.ymin-.1*u)/s/u)})}return o}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(s!=null&&s.length)return s[t-1];const n=e**t;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(t,i,s,e){const{spatialReference:n,nativeExtent:a,storageInfo:r}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=r,h=e&&c!=null?c.tileSize[0]:r.blockWidth,d=e&&c!=null?c.tileSize[1]:r.blockHeight,u=fe(t,n,s);if(!a.intersects(u)||i<0||i>o)return null;const f=this.getPyramidPixelSize(i),{x:p,y:b}=f,x=(l.y-u.y)/b/d,m=(u.x-l.x)/p/h,I=Math.min(d-1,Math.floor((x-Math.floor(x))*d)),R=Math.min(h-1,Math.floor((m-Math.floor(m))*h));return{pyramidLevel:i,row:Math.floor(x),col:Math.floor(m),rowOffset:I,colOffset:R,blockWidth:h,srcLocation:u}}getTileExtent(t,i,s,e,n,a){const[r,o]=a,l=e.x+s*r*t.x,c=l+r*t.x,h=e.y-i*o*t.y,d=h-o*t.y;return new V({xmin:l,xmax:c,ymin:d,ymax:h,spatialReference:n})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,s){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<s||e.minRow>i||e.minCol>s}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:s,height:e}=t,n=be.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new V({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-e,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new W({x:1,y:1,spatialReference:n});const{extent:a,storageInfo:r}=t;if(r){r.origin=new W({x:a.xmin,y:a.ymax,spatialReference:n});const{pyramidResolutions:o,tileInfo:l}=r;if(o&&o.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=r.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((h,d)=>{h.resolution=c*2**d,h.scale=96*h.resolution/.0254})}}}async _fetchPixels(t,i,s,e={}){let n=Y(t);if(n>=2)return{extent:t,pixelBlock:null};const a=this._getSourceDataInfo(t,i,s,e),{pyramidLevel:r,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:h,ul:d}=a;if(c===0||h===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:u}=this,f=u.transform,p=f?.type==="gcs-shift",b=U(t.spatialReference)!=null;!p&&b||(n=Y(a.srcExtent,p));const x=await this._fetchRawTiles(r,d,{width:c,height:h,wrapCount:n},e);if(!x)return{extent:t,srcExtent:l,pixelBlock:null};const m=u.storageInfo,I=r>0?m.pyramidBlockWidth:m.blockWidth,R=r>0?m.pyramidBlockHeight:m.blockHeight;let{x:F,y:L}=u.pixelSize;if(r>0){const{pyramidResolutions:E,pyramidScalingFactor:Fe}=m;if(E!=null&&E[r-1])({x:F,y:L}=E[r-1]);else{const se=Fe**r;F*=se,L*=se}}const B=u.spatialReference,$=new W({x:F,y:L,spatialReference:B}),z=I===c&&R===h&&d.x%I==0&&d.y%R==0,N=new W({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),M=!t.spatialReference.equals(B),P=B.isGeographic?1e-9:1e-4,{datumTransformation:G}=e;if(!M&&z&&x.pixelBlocks.length===1&&I===i&&R===s&&St(o,N,P))return{extent:t,srcExtent:l,srcTilePixelSize:$,pixelBlock:x.pixelBlocks[0]};const S=b&&U(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,k=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");k&&!this.rasterJobHandler&&await te();const v=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:N.toJSON(),datumTransformation:G,rasterTransform:f,hasWrapAround:n>0||S,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:k},e):pt({projectedExtent:t,srcBufferExtent:x.extent,pixelSize:N,datumTransformation:G,rasterTransform:f,hasWrapAround:n>0||S,isAdaptive:!1,includeGCSGrid:k});let J;const C=!e.requestRawData,D={rows:v.spacing[0],cols:v.spacing[1]},_=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(r,x.extent.xmin):void 0,{pixelBlocks:T,mosaicSize:O,isPartiallyFilled:q}=x;let H=null;if(this.rasterJobHandler)({pixelBlock:J,localNorthDirections:H}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:T,srcMosaicSize:O,destDimension:C?{width:i,height:s}:null,coefs:C?v.coefficients:null,sampleSpacing:C?D:null,projectDirections:k,gcsGrid:k?v.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:_,blockWidths:null},e));else{const E=Z(T,O,{alignmentInfo:_});J=C?ve(E,{width:i,height:s},v.coefficients,D,e.interpolation):E,k&&v.gcsGrid&&(H=lt({width:i,height:s},v.gcsGrid),J=ct(J,this.rasterInfo.dataType,H))}return e.requestRawData||k?{extent:t,srcExtent:l,srcTilePixelSize:$,pixelBlock:J,transformGrid:v,localNorthDirections:H,isPartiallyFilled:q}:{extent:t,srcExtent:l,srcTilePixelSize:$,pixelBlock:J}}async _fetchRawTiles(t,i,s,e){const{origin:n,blockBoundary:a}=this.rasterInfo.storageInfo,{blockWidth:r,blockHeight:o}=this.getBlockWidthHeight(t);let{x:l,y:c}=i,{width:h,height:d,wrapCount:u}=s;const f=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(l-=e.buffer.cols,c-=e.buffer.rows,h+=2*e.buffer.cols,d+=2*e.buffer.rows);let p=0,b=0,x=0;u&&f!=null&&({worldColumnCountFromOrigin:b,originColumnOffset:x,rightPadding:p}=f,b*f.blockWidth-p>=l+h&&(p=0));const m=Math.floor(l/r),I=Math.floor(c/o),R=Math.floor((l+h+p-1)/r),F=Math.floor((c+d+p-1)/o),L=a[t];if(!L)return null;const{minRow:B,minCol:$,maxCol:z,maxRow:N}=L;if(u===0&&(F<B||R<$||I>N||m>z))return null;const M=new Array;let P=!1;const G=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let _=I;_<=F;_++)for(let T=m;T<=R;T++){let O=T;if(!e.disableWrapAround&&u&&f!=null&&b<=T&&(O=T-b-x),_>=B&&O>=$&&N>=_&&z>=O){const q=this._tileFetchQueue.push({pyramidLevel:t,row:_,col:O,options:e},{signal:e.signal});G?M.push(new Promise(H=>{q.then(E=>H(E)).catch(()=>{P=!0,H(null)})})):M.push(q)}else M.push(Promise.resolve(null))}if(M.length===0)return null;const S=await Promise.all(M),k={height:(F-I+1)*o,width:(R-m+1)*r},{spatialReference:v}=this.rasterInfo,J=this.getPyramidPixelSize(t),{x:C,y:D}=J;return{extent:new V({xmin:n.x+m*r*C,xmax:n.x+(R+1)*r*C,ymin:n.y-(F+1)*o*D,ymax:n.y-I*o*D,spatialReference:v}),pixelBlocks:S,mosaicSize:k,isPartiallyFilled:P}}_fetchRawTile(t,i,s,e){const n=this.rasterInfo.storageInfo.blockBoundary[t];if(!n)return Promise.resolve(null);const{minRow:a,minCol:r,maxCol:o,maxRow:l}=n;if(i<a||s<r||i>l||s>o)return Promise.resolve(null);const c=he(this.rasterId,e.sliceId),h=`${t}/${i}/${s}`;let d=de(c,e.registryId,h);if(d==null){const u=new AbortController;d=this.fetchRawTile(t,i,s,{...e,signal:u.signal}),me(c,e.registryId,h,d,u),d.catch(()=>at(c,e.registryId,h))}return e.signal&&Pe(e,()=>{ot(c,e.registryId,h)}),d}_computeMagDirValues(t){const{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||t?.length!==2||!t[0]?.length)return null;const e=t[0].length;if(s==="vector-magdir"){const l=t[1].map(c=>(c+360)%360);return[t[0],l]}const[n,a]=t,r=[],o=[];for(let l=0;l<e;l++){const[c,h]=ut([n[l],a[l]]);r.push(c),o.push(h)}return[r,o]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=yt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,s,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,n));const a=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:r,srcHeight:o,pyramidLevel:l}=n,c=r/i,h=o/s,d=l<a&&c*h>=16,u=l===a&&this._requireTooManySrcTiles(r,o,i,s);if(d||u||r===0||o===0){const f=new W({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let p=xt(f,this.rasterInfo.spatialReference,t,n.datumTransformation);const b=!p||e.srcResolution&&p.x+p.y<e.srcResolution.x+e.srcResolution.y;if(d&&e.srcResolution&&b){const x=Math.round(Math.log(Math.max(c,h))/Math.LN2)-1;if(a-l+3>=x){const m=2**x;p={x:e.srcResolution.x*m,y:e.srcResolution.y*m}}}p&&(n.srcResolution=p,this._updateSourceDataInfo(t,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,s)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(t,i,s,e){const{tileInfo:n}=this.rasterInfo.storageInfo,a=Math.ceil(t/n.size[0])*Math.ceil(i/n.size[1]),r=t/s,o=i/e,l=Math.max(1,(s+e)/1024);return a>=It*l||r>ye||o>ye}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:s}=this,e=s.spatialReference,{srcResolution:n,datumTransformation:a}=i,{pyramidLevel:r,pyramidResolution:o,excessiveReading:l}=pe(n,s,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||Q(t,e,a);if(c==null)return;const h=s.transform;h&&(c=h.inverseTransform(c)),i.srcExtent=c;const{x:d,y:u}=s.storageInfo.origin,f=Math.floor((c.xmin-d)/o.x+.1),p=Math.floor((u-c.ymax)/o.y+.1),b=Math.floor((c.xmax-d)/o.x-.1),x=Math.floor((u-c.ymin)/o.y-.1),m=c.width<.1*o.x?0:b-f+1,I=c.height<.1*o.y?0:x-p+1;i.pyramidLevel=r,i.pyramidResolution=o,i.srcWidth=m,i.srcHeight=I,i.ul={x:f,y:p}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:s,position:e,pyramidLevel:n,useTransposedTile:a}=i,r=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:s,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!a){const x=t.pixels.map(R=>R[e]),m={location:s,value:x,pyramidLevel:n},I=this._computeMagDirValues(x.map(R=>[R]));return I?.length&&(m.magdirValue=I.map(R=>R[0])),m}let l=t.pixels.map(x=>x.slice(e*r,e*r+r)),c=this._computeMagDirValues(l);const{requestSomeSlices:h,identifyOptions:d}=i;let u=ze(o,d.transposedVariableName);if(h){const x=Ne(u,d.multidimensionalDefinition,d.timeExtent);l=l.map(m=>x.map(I=>m[I])),c=c?.map(m=>x.map(I=>m[I])),u=x.map(m=>u[m])}const f=t.noDataValues||this.rasterInfo.noDataValue,p={pixels:l,pixelType:t.pixelType};let b;return f!=null&&(ht(p,f),b=p.mask),{location:s,value:null,dataSeries:u.map((x,m)=>{const I={value:b?.[m]===0?null:l.map(R=>R[m]),multidimensionalDefinition:x.multidimensionalDefinition.map(R=>new Se({...R,isSlice:!0}))};return c?.length&&(I.magdirValue=[c[0][m],c[1][m]]),I}),pyramidLevel:n}}};function St(t,i,s){return Math.abs(t.x-i.x)<s&&Math.abs(t.y-i.y)<s}y([g()],w.prototype,"_rasterTileAlignmentInfo",void 0),y([g()],w.prototype,"_tileFetchQueue",void 0),y([g({readOnly:!0})],w.prototype,"_isGlobalWrappableSource",null),y([g({readOnly:!0})],w.prototype,"_hasNoneOrGCSShiftTransform",null),y([g()],w.prototype,"_openPromise",void 0),y([g()],w.prototype,"rasterJobHandler",null),y([g({readOnly:!0})],w.prototype,"rasterId",null),y([g(Ie)],w.prototype,"url",null),y([g({type:String,json:{write:!0}})],w.prototype,"datasetName",void 0),y([g({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),y([g()],w.prototype,"hasUniqueSourceStorageInfo",void 0),y([g()],w.prototype,"rasterInfo",void 0),y([g()],w.prototype,"ioConfig",void 0),y([g()],w.prototype,"sourceJSON",void 0),w=y([re("esri.layers.support.rasterDatasets.BaseRaster")],w);const vt=w,_t=40;let A=class extends vt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,s,e={}){const{rasters:n,rasterIds:a}=this.primaryRasters;let r=!1;const{interpolation:o}=e,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!e.requestRawData&&l&&(r=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:r});const c=n.map(R=>R.fetchPixels(t,i,s,e)),h=await Promise.all(c),d=h.map(R=>R.pixelBlock),u=r||e.requestRawData?h.map(R=>R.srcTilePixelSize):null;if(e.skipRasterFunction||d.every(R=>R==null))return h[0];const f=h.find(R=>R.pixelBlock!=null)?.extent??t;let p=this.rasterJobHandler?await this.rasterJobHandler.process({extent:f,primaryPixelBlocks:d,primaryPixelSizes:u,primaryRasterIds:a}):this.rasterFunction.process({extent:f,primaryPixelBlocks:d,primaryPixelSizes:u,primaryRasterIds:a});const{transformGrid:b}=h[0];if(!r||p==null||b==null){const R=e.noClip?null:this.getClippingGeometry(f.spatialReference);return e.noClip||e.requestRawData||p==null||!R||(p=await ne(p,f,R)),{...h[0],pixelBlock:p}}const x={rows:b.spacing[0],cols:b.spacing[1]};let m;this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[p],srcMosaicSize:{width:p.width,height:p.height},destDimension:{width:i,height:s},coefs:b.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:m=ve(p,{width:i,height:s},b.coefficients,x,o);const I=e.noClip?null:this.getClippingGeometry(t.spatialReference);return e.noClip||e.requestRawData||m==null||I==null||(m=await ne(m,t,I)),{extent:t,srcExtent:h[0].srcExtent,pixelBlock:m}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const s=kt(t);let e=this._clippingGeometry.get(s);return e!=null||(e=t.equals(i.spatialReference)?i:ie(i,t),this._clippingGeometry.set(s,e)),e}async _open(t){const{rasterFunction:i}=this;this.primaryRasters?.rasters?.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(c=>c.rasterJobHandler=this.rasterJobHandler));const{rasters:s,rasterIds:e}=this.primaryRasters,n=s.map(c=>c.rasterInfo?void 0:c.open(t));await Promise.all(n);const a=s.map(({rasterInfo:c})=>c),r=i.bind({rasterInfos:a,rasterIds:e});if(i.rawSourceRasterInfos=a,!r.success||a.length===0)throw new j("raster-function:open",`cannot bind the function: ${r.error??""}`);const o=i.functionName==="Table"?i:i.functionArguments?.raster;o?.functionName==="Table"&&(i.rasterInfo.attributeTable=bt.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=a[0];this.hasUniqueSourceStorageInfo=a.length===1||a.slice(1).every(c=>Ft(c,l)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t?.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:s}=this.rasterInfo,{difference:e,densify:n}=await rt(async()=>{const{difference:r,densify:o}=await import("./geometryEngine-CVDxMhql.js");return{difference:r,densify:o}},__vite__mapDeps([0,1,2,3,4,5,6]),import.meta.url);let a=n(Je.fromExtent(s),2*(s.width+s.height)/_t);a=ie(a,i.spatialReference),i=e(a,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};y([g({type:String,json:{write:!0}})],A.prototype,"datasetFormat",void 0),y([g()],A.prototype,"tileType",void 0),y([g()],A.prototype,"rasterFunction",void 0),y([g()],A.prototype,"primaryRasters",void 0),A=y([re("esri.layers.support.rasterDatasets.FunctionRaster")],A);const Tt=A;function Ft(t,i){const{storageInfo:s,pixelSize:e,spatialReference:n,extent:a}=t,{storageInfo:r,pixelSize:o,spatialReference:l,extent:c}=i;return e.x===o.x&&e.y===o.y&&n.equals(l)&&a.equals(c)&&s.blockHeight===r.blockHeight&&s.blockWidth===r.blockWidth&&s.maximumPyramidLevel===r.maximumPyramidLevel}function kt(t){return String(t.wkid??t.wkt??t.wkt2)}const Gt=t=>{let i=class extends t{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=e[0]?.raster?.datasetFormat==="Function"}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){e?.functionName?.toLowerCase()==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",xe(e,ee.getLogger(this)))}get renderer(){if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;return e?n?.find(({name:r})=>r===e)?.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,a){const r=n?.layerDefinition?.drawingInfo?.renderer;return Ae(r,a)||void 0}async convertVectorFieldData(e,n){const{serviceRasterInfo:a}=this;if(e==null||!a)return null;const r=this._rasterJobHandler.instance,o=a.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:o},n):dt(e,o)}async computeStatisticsHistograms(e,n){await this.load(n),e=ge(je,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=e;if(r==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let o=r;const{spatialReference:l}=a;r.spatialReference.equals(l)||(await te(),o=r.type==="extent"?Q(r,l):ie(r,l));const c=e.pixelSize??new W({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:l}),{extent:h,width:d,height:u}=gt(a,o,c),f=await this.fetchPixels(h,d,u,{...n,interpolation:"nearest"});if(f.pixelBlock==null)throw new j("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const p=await ne(f.pixelBlock,h,o),b=this._rasterJobHandler.instance;return b?b.computeStatisticsHistograms({pixelBlock:p},n):tt(p)}async createFlowMesh(e,n){const a=this._rasterJobHandler.instance;return a?a.createFlowMesh(e,n):mt(e.meshType,e.simulationSettings,e.flowData,n.signal!=null?n.signal:new AbortController().signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const a=Me({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a}}async updateRasterFunction(){return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n}=this;if(!e||!n||!this.renderer)return;const{rasterInfo:a}=this.raster,r=ae(a,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=r?.name,l=le({...this.renderer.toJSON(),variableName:o});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(l))return;const c=this._rasterJobHandler.instance;c&&(n.rasterInfo=ce(a,o),n.rendererJSON=l,n.bind(),await c.updateSymbolizer(n),this._cachedRendererJson=l)}async applyRenderer(e,n){const a=e?.pixelBlock;if(!(a!=null&&a.pixels&&a.pixels.length>0))return null;let r;await this.updateRenderer();const o=this._rasterJobHandler.instance,l=this.bandIds??[];return r=o?await o.symbolize({...e,simpleStretchParams:n,bandIds:l}):this.symbolizer.symbolize({...e,simpleStretchParams:n,bandIds:l}),r}getTileUrl(e,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${a}`:""}getCompatibleTileInfo(e,n,a=!1){if(!this.loaded||n==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const r=Be(e);return X.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,a,r={}){if(s(this),r.requestAsImageElement){const l=this.getTileUrl(e,n,a);return Re(l,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(c=>c.data)}const{serviceRasterInfo:o}=this;if(o.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){const l=r.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,a,l),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),this.renderer?.type==="raster-shaded-relief"&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,a,r)}async fetchPixels(e,n,a,r={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a),this.raster.fetchPixels(e,n,a,r))}async identify(e,n={}){await this.load();const{raster:a,serviceRasterInfo:r}=this;if(r?.multidimensionalInfo!=null&&!(r.hasMultidimensionalTranspose&&(we(n.multidimensionalDefinition)||n.transposedVariableName||n.timeExtent))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const o=this.multidimensionalSubset?.areaOfInterest;if(o&&!o.contains(e))throw new j("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return a.identify(e,n)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(e==null||this.serviceRasterInfo?.dataType!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=n?.[0]?.variableName;return e.variables.some(r=>r.name===a&&(!n?.[0].dimensionName||r.dimensions.some(o=>o.name==="StdTime")))}getStandardTimeValue(e){return new Date(Oe(e)).toISOString()}getMultidimensionalSubsetVariables(e){const n=e??this.serviceRasterInfo?.multidimensionalInfo;return Ee(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=We(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&this.raster.datasetFormat==="Function"&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const e=new Ke;return this._rasterJobHandler.connectionPromise=e.initialize().then(async()=>{s(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(this.interpolation==null){s(this);const{raster:e}=this,n=Ve(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",n)}}_configDefaultRenderer(e="no"){s(this);const{rasterInfo:n}=this.raster,a=ae(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=a?.name,o=Ue({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=o?.bandIds??Qe(n)),!this.renderer||e==="override"){const d=Xe(this.raster),u=o?.renderer??ue(n,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:d}),f=n.statistics,p=f&&f.length>0?f[0]:null,b=p?.max??0,x=p?.min??0;this.raster.datasetFormat==="WCSServer"&&u.type==="raster-stretch"&&(b>1e24||x<-1e24)&&(u.dynamicRangeAdjustment=!0,u.customStatistics=null,u.stretchType==="none"&&(u.stretchType="min-max")),this.renderer=u}const l=le({...this.renderer.toJSON(),variableName:r}),c=ce(n,r);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=c):this.symbolizer=new it({rendererJSON:l,rasterInfo:c});const h=this.symbolizer.bind();if(h.success){if(e==="auto"){const{colormap:d}=this.raster.rasterInfo,u=this.renderer;if(d!=null&&u.type==="raster-colormap"){const f=ue(this.raster.rasterInfo);JSON.stringify(f)!==JSON.stringify(u)&&this._configDefaultRenderer("override")}else if(u.type==="raster-stretch"){const f=this.bandIds?.length,p=u.customStatistics?.length;!u.dynamicRangeAdjustment&&p&&f&&p!==f&&this._configDefaultRenderer("override")}}}else ee.getLogger(this).warn("imagery-tile-mixin",h.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&this.raster.datasetFormat==="Function"){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",oe.fromJSON(h)))}let e,n=this.raster,a=!1;n.datasetFormat==="Function"?(e=n.primaryRasters.rasters,n=e[0],a=!0):e=[n];const{rasterFunction:r}=this;if(r){const h={raster:n};e.length>1&&e.forEach(f=>h[f.url]=f);const d=Rt(r.functionDefinition?.toJSON()??r.toJSON(),h),u=new Tt({rasterFunction:d});u.rasterJobHandler=this._rasterJobHandler.instance,await u.open(),this.raster=u}else this.raster=n,await n.open();if(this._cachedRendererJson=null,!a&&!r)return;const{bandIds:o}=this,{bandCount:l}=this.raster.rasterInfo,c=o?.length?o.some(h=>h>=l):l>=3;o&&(c||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function s(e){if(!e.raster||!e.serviceRasterInfo)throw new j("imagery-tile","no raster")}return y([g({clonable:!1})],i.prototype,"_cachedRendererJson",void 0),y([g({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),y([g({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),y([g({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),y([g({clonable:!1})],i.prototype,"_rasterJobHandler",void 0),y([g({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),y([g({type:[He],json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.bandIds?.join(",")!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),y([g({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),y([g({json:{read:!1}})],i.prototype,"fullExtent",null),y([g({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Ce(et)],i.prototype,"interpolation",void 0),y([g()],i.prototype,"ioConfig",void 0),y([g({type:[Se],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),y([g({type:Le,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),y([g()],i.prototype,"raster",void 0),y([g({type:oe})],i.prototype,"rasterFunction",null),y([g()],i.prototype,"serviceRasterInfo",void 0),y([g()],i.prototype,"sourceJSON",void 0),y([g({readOnly:!0,type:be,json:{read:!1}})],i.prototype,"spatialReference",void 0),y([g({type:X})],i.prototype,"tileInfo",void 0),y([g(Ie)],i.prototype,"url",null),y([g()],i.prototype,"renderer",null),y([g({types:Ge,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e=this.renderer?.type==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:qe,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],i.prototype,"internalRenderer",null),y([De("internalRenderer")],i.prototype,"readRenderer",null),y([g({clonable:!1})],i.prototype,"symbolizer",void 0),i=y([re("esri.layers.mixins.ImageryTileMixin")],i),i};function K(t,i){if(!t||!i)return[];let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=[];if(i){const a=K(t,s);for(let r=0;r<a.length;r++)K(a[r],i).forEach(o=>e.push(o));return e}const n=t.getElementsByTagNameNS("*",s);if(!n||n.length===0)return[];for(let a=0;a<n.length;a++)e.push(n[a]||n.item(a));return e}function _e(t,i){if(!t||!i)return null;let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=K(t,s);return e.length>0?i?_e(e[0],i):e[0]:null}function Te(t,i=null){const s=i?_e(t,i):t;let e;return s?(e=s.textContent||s.nodeValue,e?e.trim():null):null}function Pt(t,i){const s=K(t,i),e=[];let n;for(let a=0;a<s.length;a++)n=s[a].textContent||s[a].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function qt(t,i=null){return Te(t,i)?.split(" ").map(e=>Number(e))??[]}function At(t,i){return Pt(t,i).map(s=>Number(s))}function jt(t,i){const s=Te(t,i);return Number(s)}function Vt(t,i){const s=t?.nodeName?.toLowerCase(),e=i.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===e}function Ut(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{Gt as K,vt as X,Tt as a,Ut as c,_e as e,Vt as i,Pt as l,K as n,jt as o,qt as r,Te as t,At as u};
