const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./HUDMaterial.glsl-n0uEjdag.js","./vec2-maR1OrZI.js","./common-DQOJ18NT.js","./vec2f64-DohEyf3f.js","./main-asQ7SttR.js","./preload-helper-ExcqyqRp.js","./main-DmIi68wH.css","./Geometry-BYkWVgnK.js","./Texture-DGW9aO8e.js","./signal-DOJnbrFR.js","./enums-Dk3osxpS.js","./getDataTypeBytes-DflDeYgv.js","./renderState-z3Gwc6C8.js","./basicInterfaces-CZwQPxTp.js","./ShaderOutput-DnYY5J1_.js","./mat4-BjwS19gr.js","./mat4f64-Dk4dwAN8.js","./vec32-BzCy6cr7.js","./BindType-BBwFZqyN.js","./glsl-BH37Aalp.js","./mat3f64-q3fE-ZOt.js","./VertexAttribute-Cq4MnHjR.js","./vec42-CKs01hkn.js","./vec4f64-o2zAXfmz.js","./mat3-CruJiiUv.js","./lengthUtils-GoFDlaqZ.js","./boundedPlane-Zz4nqCih.js","./sphere-DET7VZHS.js","./plane-RIh6ulrU.js","./quatf64-aQ5IuZRd.js","./lineSegment-BNFfqofa.js","./ViewingMode-HRfKv6NR.js","./projectBuffer-Cx7kBt8y.js","./orientedBoundingBox-BH0jY8bO.js","./quat-sVWee8SJ.js","./spatialReferenceEllipsoidUtils-Bq6Bg_Dl.js","./computeTranslationToOriginAndRotation-njxIHGyK.js","./requestImageUtils-DZzdNdYu.js","./TextureFormat-1mYWTFa-.js","./InterleavedLayout-CkdA0S5-.js","./BufferView-CVke7kmB.js","./types-D0PSWh4d.js","./Indices-Vgv1m-UC.js","./triangle-C4BV5fZD.js","./glUtil-BuljoYCz.js","./VertexElementDescriptor-BOD-G50G.js","./IntersectorInterfaces-BgX4KEwK.js","./Octree-DqQOkamU.js","./VertexArrayObject-h88j0new.js","./memoryEstimations-COo-dz1M.js","./dehydratedFeatureUtils-lt-r3GBb.js","./doublePrecisionUtils-B0owpBza.js","./projection-G6EI4E6A.js","./meshVertexSpaceUtils-DhVTAb0c.js","./MeshLocalVertexSpace-Dk8C03Rj.js","./projectVectorToVector-VmpAJgQc.js","./projectPointToVector-CbyHCjYt.js","./hydratedFeatures-Biiv0j5A.js","./vec3f32-nZdmKIgz.js","./DefaultMaterial-IOvhxCYs.js","./NormalAttribute.glsl-C7KdSkvm.js","./ShaderBuilder-DGYV3P6E.js","./HighlightDefaults-D0LIiYIH.js","./Scheduler-CssyMp54.js"])))=>i.map(i=>d[i]);
import{aN as it,B as a,D as p,N as xt,aK as E,fO as Tt,iR as te,n as Ot,ju as St,af as Pt,aR as bt,c4 as $t,d4 as Ct,cF as Mt}from"./main-asQ7SttR.js";import{n as I,u as rt,f as ve}from"./ShaderOutput-DnYY5J1_.js";import{n as ge,c as ze,h as ne,s as Dt,A as At,C as Et,X as Rt}from"./mat4-BjwS19gr.js";import{e as N}from"./mat4f64-Dk4dwAN8.js";import{r as st,E as Ft,o as De,I as zt}from"./vec2-maR1OrZI.js";import{t as ot,n as Ae}from"./vec2f64-DohEyf3f.js";import{c as ae,o as U,p as nt,s as L,H as ie,R as Ie,P as be,Z as je,X as It,g as V,r as X,_ as Le,A as he,K as jt,E as le,u as me,N as Lt}from"./vec32-BzCy6cr7.js";import{m as Ve,L as Be,E as _e,a as re,x as Ne,z as se}from"./vec42-CKs01hkn.js";import{r as $e,n as G,e as Ce,s as Vt,u as Bt}from"./vec4f64-o2zAXfmz.js";import{H as Nt,N as Ut,L as Ht}from"./Octree-DqQOkamU.js";import{b as qt}from"./sphere-DET7VZHS.js";import{f as Gt}from"./plane-RIh6ulrU.js";import{l as Wt}from"./ViewingMode-HRfKv6NR.js";import{o as Xt}from"./VertexArrayObject-h88j0new.js";import{o as kt}from"./floatRGBA-Dmu5dBAP.js";import{q as Yt,N as Qt,r as Zt,t as Jt,s as Kt,u as ei,v as ti,x as ii,o as ri,y as Ue,z as we,e as He,w as si,A as oi,i as ni,B as H,C as ai,k as li,g as ci,D as hi,E as J,F as ui,G as pi,T as di,H as fi,I as S,J as vi,K as gi,L as mi,M as _i,O as W,P as wi,Q as yi,R as xi,S as qe,U as Ti,W as Oi,V as Si,X as Pi,Y as bi,Z as $i,_ as Ci,$ as Mi,a0 as Di,a1 as Ai,a2 as Ge,a3 as We,a4 as Ei}from"./Geometry-BYkWVgnK.js";import{D as Xe,E as ke,O as Ri}from"./enums-Dk3osxpS.js";import{n as at}from"./mat3-CruJiiUv.js";import{e as lt}from"./mat3f64-q3fE-ZOt.js";import{x as Fi}from"./BufferView-CVke7kmB.js";import{H as zi,s as Ii}from"./InterleavedLayout-CkdA0S5-.js";import{l as ct,u as ji,n as Li,t as Vi,d as Bi}from"./dehydratedFeatureUtils-lt-r3GBb.js";import{e as _}from"./VertexAttribute-Cq4MnHjR.js";import{n as f,t as P}from"./glsl-BH37Aalp.js";import{a as Ni}from"./BindType-BBwFZqyN.js";import{i as Ui}from"./ShaderBuilder-DGYV3P6E.js";import{_ as Hi}from"./preload-helper-ExcqyqRp.js";import{B as qi,o as Gi,p as Wi,g as Xi}from"./renderState-z3Gwc6C8.js";let ki=class extends Yt{constructor(t,i){super(t,"vec4",Ni.Draw,(r,s,o)=>r.setUniform4fv(t,i(s,o)))}};const Yi={required:[]};I.Depth;let ht=class extends it{precompile(t){return!!this.acquireTechniques(t)}consumes(){return Yi}get usedMemory(){return 0}get isDecoration(){return!1}get running(){return!1}modify(t){}get numGeometries(){return 0}get hasOccludees(){return!1}get hasEmissions(){return!1}forEachGeometry(t){}queryRenderOccludedState(t){return!1}},ns=class extends ht{},ls=class extends ht{};function Qi(e,t,i){return 2*Math.atan(Math.sqrt(t*t+i*i)*Math.tan(.5*e)/t)}function Zi(e,t,i){return 2*Math.atan(Math.sqrt(t*t+i*i)*Math.tan(.5*e)/i)}function Ji(e,t,i){return 2*Math.atan(t*Math.tan(.5*e)/Math.sqrt(t*t+i*i))}function Ki(e,t,i){return 2*Math.atan(i*Math.tan(.5*e)/Math.sqrt(t*t+i*i))}var Ye,y;(function(e){e[e.Default=0]="Default",e[e.Screenshot=1]="Screenshot",e[e.ObjectAndLayerID=2]="ObjectAndLayerID"})(Ye||(Ye={})),function(e){e[e.TOP=0]="TOP",e[e.RIGHT=1]="RIGHT",e[e.BOTTOM=2]="BOTTOM",e[e.LEFT=3]="LEFT"}(y||(y={}));var Me;let u=Me=class extends it{constructor(e){super(e),this._ray=qt(),this._viewport=$e(0,0,1,1),this._padding=$e(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=ot(1,1e3),this._viewDirty=!0,this._viewMatrix=N(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=N(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=N(),this._frustumDirty=!0,this._frustum=Nt(),this._fullViewport=G(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=E(),this._up=E(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(e){this._pixelRatio=e>0?e:1}get rows(){return this._rows}set rows(e){this._rows=Math.max(1,e)}get columns(){return this._columns}set columns(e){this._columns=Math.max(1,e)}get eye(){return this._ray.origin}set eye(e){this._compareAndSetView(e,this._ray.origin)}get center(){return this._center}set center(e){this._compareAndSetView(e,this._center,"_center")}get ray(){return ae(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(e){this._compareAndSetView(e,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(e){ge(this._viewMatrix,e),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),U(E(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),U(E(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),U(E(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(e){this._nearFar[0]!==e&&(this._nearFar[0]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(e){this._nearFar[1]!==e&&(this._nearFar[1]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(e){this.x=e[0],this.y=e[1],this.width=e[2],this.height=e[3]}get screenViewport(){if(this.pixelRatio===1)return this._viewport;const e=Ve(G(),this._viewport,1/this.pixelRatio),t=this._get("screenViewport");return t&&Be(e,t)?t:e}get screenPadding(){if(this.pixelRatio===1)return this._padding;const e=Ve(G(),this._padding,1/this.pixelRatio),t=this._get("screenPadding");return t&&Be(e,t)?t:e}get x(){return this._viewport[0]}set x(e){e+=this._padding[y.LEFT],this._viewport[0]!==e&&(this._viewport[0]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(e){e+=this._padding[y.BOTTOM],this._viewport[1]!==e&&(this._viewport[1]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(e){this._viewport[2]!==e&&(this._viewport[2]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(e){this._viewport[3]!==e&&(this._viewport[3]=e,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[y.RIGHT]+this._padding[y.LEFT]}set fullWidth(e){this.width=e-(this._padding[y.RIGHT]+this._padding[y.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[y.TOP]+this._padding[y.BOTTOM]}set fullHeight(e){this.height=e-(this._padding[y.TOP]+this._padding[y.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[y.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[y.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(e){_e(this._padding,e)||(this._viewport[0]+=e[y.LEFT]-this._padding[y.LEFT],this._viewport[1]+=e[y.BOTTOM]-this._padding[y.BOTTOM],this._viewport[2]-=e[y.RIGHT]+e[y.LEFT]-(this._padding[y.RIGHT]+this._padding[y.LEFT]),this._viewport[3]-=e[y.TOP]+e[y.BOTTOM]-(this._padding[y.TOP]+this._padding[y.BOTTOM]),re(this._padding,e),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&(ze(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){return this._projectionMatrixInternal}get inverseProjectionMatrix(){return ne(N(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||N()}get fov(){return this._fov}set fov(e){this._fov=e,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return Ji(this._fov,this.width,this.height)}set fovX(e){this._fov=Qi(e,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return Ki(this._fov,this.width,this.height)}set fovY(e){this._fov=Zi(e,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return nt(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(ne(this._viewInverseTransposeMatrix,this.viewMatrix),Dt(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(e){const{near:t,far:i}=this;return 2*t*i/(i+t-e*(i-t))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation!=null&&this.relativeElevation>=0}get _projectionMatrixInternal(){const e=this.width,t=this.height,i=this.near*Math.tan(this.fovY/2)*2,r=i*this._aspect,s=i/this.rows,o=r/this.columns,n=-r/2+this.column*o,l=n+o,c=-i/2+this.row*s,h=c+s,m=At(N(),n*(1+2*this._padding[y.LEFT]/e),l*(1+2*this._padding[y.RIGHT]/e),c*(1+2*this._padding[y.BOTTOM]/t),h*(1+2*this._padding[y.TOP]/t),this.near,this.far),v=this._get("projectionMatrix");return v&&Et(v,m)?v:m}copyFrom(e){L(this._ray.origin,e.eye),this.center=e.center,this.up=e.up,re(this._viewport,e.viewport),this.notifyChange("_viewport"),re(this._padding,e.padding),this.notifyChange("_padding"),st(this._nearFar,e.nearFar),this.notifyChange("_nearFar"),this._fov=e.fov,this.row=e.row,this.column=e.column,this.rows=e.rows,this.columns=e.columns,this.relativeElevation=e.relativeElevation;const t=e;return this._viewDirty=t._viewDirty,this._viewDirty||(ge(this._viewMatrix,e.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=t._frustumDirty,this._frustumDirty||(Ut(this._frustum,e.frustum),this._frustumDirty=!1),t._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(ge(this._viewInverseTransposeMatrix,e.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),re(this._fullViewport,e.fullViewport),this.pixelRatio=e.pixelRatio,this}copyViewFrom(e){this.eye=e.eye,this.center=e.center,this.up=e.up,this.fov=e.fov}clone(){return new Me().copyFrom(this)}equals(e){return ie(this.eye,e.eye)&&ie(this.center,e.center)&&ie(this.up,e.up)&&_e(this._viewport,e.viewport)&&_e(this._padding,e.padding)&&Ft(this.nearFar,e.nearFar)&&this._fov===e.fov&&this.pixelRatio===e.pixelRatio&&this.relativeElevation===e.relativeElevation&&this.row===e.row&&this.column===e.column&&this.rows===e.rows&&this.columns===e.columns}almostEquals(e){const t=Math.max(1,1/this.pixelRatio,1/e.pixelRatio);if(Math.abs(e.fov-this._fov)>=.001||Ne(e.screenPadding,this.screenPadding)>=t||Ne(this.screenViewport,e.screenViewport)>=t||this.row!==e.row||this.column!==e.column||this.rows!==e.rows||this.columns!==e.columns)return!1;Ie(b,e.eye,e.center),Ie(ye,this.eye,this.center);const i=be(b,ye),r=je(b),s=je(ye),o=5e-4;return i*i>=(1-1e-10)*r*s&&It(e.eye,this.eye)<Math.max(r,s)*o*o}computeRenderPixelSizeAt(e){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(e))}computeRenderPixelSizeAtDist(e){return e*this.perRenderPixelRatio}computeScreenPixelSizeAt(e){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(e))}_viewDirectionDistance(e){return Math.abs(Gt(this.viewForward,ae(b,e,this.eye)))}computeScreenPixelSizeAtDist(e){return e*this.perScreenPixelRatio}computeDistanceFromRadius(e,t){return e/Math.tan(Math.min(this.fovX,this.fovY)/(2*(t||1)))}getScreenCenter(e=Tt()){return e[0]=(this.padding[y.LEFT]+this.width/2)/this.pixelRatio,e[1]=(this.padding[y.TOP]+this.height/2)/this.pixelRatio,e}getRenderCenter(e,t=.5,i=.5){return e[0]=this.padding[y.LEFT]+this.width*t,e[1]=this.padding[y.BOTTOM]+this.height*i,e[2]=.5,e}setGLViewport(e){const t=this.viewport,i=this.padding;e.setViewport(t[0]-i[3],t[1]-i[2],t[2]+i[1]+i[3],t[3]+i[0]+i[2])}applyProjection(e,t){e!==g&&L(g,e),g[3]=1,se(g,g,this.projectionMatrix);const i=Math.abs(g[3]);V(g,g,1/i);const r=this.fullViewport;t[0]=te(0,r[0]+r[2],.5+.5*g[0]),t[1]=te(0,r[1]+r[3],.5+.5*g[1]),t[2]=.5*(g[2]+1),t[3]=i}unapplyProjection(e,t){const i=this.fullViewport;g[0]=(e[0]/(i[0]+i[2])*2-1)*e[3],g[1]=(e[1]/(i[1]+i[3])*2-1)*e[3],g[2]=(2*e[2]-1)*e[3],g[3]=e[3],this.inverseProjectionMatrix!=null&&(se(g,g,this.inverseProjectionMatrix),t[0]=g[0],t[1]=g[1],t[2]=g[2])}projectToScreen(e,t){return this.projectToRenderScreen(e,xe),this.renderToScreen(xe,t),t}projectToRenderScreen(e,t){if(g[0]=e[0],g[1]=e[1],g[2]=e[2],g[3]=1,se(g,g,this.viewProjectionMatrix),g[3]===0)return null;const i=g;V(i,i,1/Math.abs(g[3]));const r=this.fullViewport,s=te(0,r[0]+r[2],.5+.5*i[0]),o=te(0,r[1]+r[3],.5+.5*i[1]);return"x"in t?(t.x=s,t.y=o):(t[0]=s,t[1]=o,t.length>2&&(t[2]=.5*(i[2]+1))),t}unprojectFromScreen(e,t){return this.unprojectFromRenderScreen(this.screenToRender(e,xe),t)}unprojectFromRenderScreen(e,t){if(ze(oe,this.projectionMatrix,this.viewMatrix),!ne(oe,oe))return null;const i=this.fullViewport;return g[0]=2*(e[0]-i[0])/i[2]-1,g[1]=2*(e[1]-i[1])/i[3]-1,g[2]=2*e[2]-1,g[3]=1,se(g,g,oe),g[3]===0?null:(t[0]=g[0]/g[3],t[1]=g[1]/g[3],t[2]=g[2]/g[3],t)}constrainWindowSize(e,t,i,r){const s=e*this.pixelRatio,o=t*this.pixelRatio,n=Math.max(s-i/2,0),l=Math.max(this.fullHeight-o-r/2,0),c=-Math.min(s-i/2,0),h=-Math.min(this.fullHeight-o-r/2,0),m=i-c- -Math.min(this.fullWidth-s-i/2,0),v=r-h- -Math.min(o-r/2,0);return[Math.round(n),Math.round(l),Math.round(m),Math.round(v)]}computeUp(e){e===Wt.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(e,t){const i=e[0]*this.pixelRatio,r=this.fullHeight-e[1]*this.pixelRatio;return t[0]=i,t[1]=r,t}renderToScreen(e,t){const i=e[0]/this.pixelRatio,r=(this.fullHeight-e[1])/this.pixelRatio;t[0]=i,t[1]=r}_computeUpGlobal(){ae(b,this.center,this.eye);const e=X(this.center);e<1?(U(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs(be(b,this.center))>.9999*X(b)*e||(Le(this._up,b,this.center),Le(this._up,this._up,b),he(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){jt(b,this.eye,this.center),Math.abs(b[2])<=.9999&&(V(b,b,b[2]),U(this._up,-b[0],-b[1],1-b[2]),he(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(e,t,i=""){typeof e[0]=="number"&&isFinite(e[0])&&typeof e[1]=="number"&&isFinite(e[1])&&typeof e[2]=="number"&&isFinite(e[2])?ie(e,t)||(L(t,e),this._markViewDirty(),i.length&&this.notifyChange(i)):Ot.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Ht(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(Rt(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};a([p()],u.prototype,"_viewport",void 0),a([p()],u.prototype,"_padding",void 0),a([p()],u.prototype,"_fov",void 0),a([p()],u.prototype,"_nearFar",void 0),a([p()],u.prototype,"_viewDirty",void 0),a([p()],u.prototype,"_viewMatrix",void 0),a([p()],u.prototype,"_pixelRatio",void 0),a([p()],u.prototype,"pixelRatio",null),a([p()],u.prototype,"row",void 0),a([p()],u.prototype,"column",void 0),a([p()],u.prototype,"_rows",void 0),a([p()],u.prototype,"rows",null),a([p()],u.prototype,"_columns",void 0),a([p()],u.prototype,"columns",null),a([p()],u.prototype,"eye",null),a([p()],u.prototype,"center",null),a([p()],u.prototype,"_center",void 0),a([p()],u.prototype,"up",null),a([p()],u.prototype,"_up",void 0),a([p()],u.prototype,"viewMatrix",null),a([p({readOnly:!0})],u.prototype,"viewForward",null),a([p({readOnly:!0})],u.prototype,"viewUp",null),a([p({readOnly:!0})],u.prototype,"viewRight",null),a([p({readOnly:!0})],u.prototype,"nearFar",null),a([p()],u.prototype,"near",null),a([p()],u.prototype,"far",null),a([p()],u.prototype,"viewport",null),a([p({readOnly:!0})],u.prototype,"screenViewport",null),a([p({readOnly:!0})],u.prototype,"screenPadding",null),a([p()],u.prototype,"x",null),a([p()],u.prototype,"y",null),a([p()],u.prototype,"width",null),a([p()],u.prototype,"height",null),a([p()],u.prototype,"fullWidth",null),a([p()],u.prototype,"fullHeight",null),a([p({readOnly:!0})],u.prototype,"_aspect",null),a([p()],u.prototype,"padding",null),a([p({readOnly:!0})],u.prototype,"projectionMatrix",null),a([p({readOnly:!0})],u.prototype,"inverseProjectionMatrix",null),a([p()],u.prototype,"fov",null),a([p()],u.prototype,"fovX",null),a([p()],u.prototype,"fovY",null),a([p()],u.prototype,"viewInverseTransposeMatrix",null),a([p({readOnly:!0})],u.prototype,"_projectionMatrixInternal",null),a([p()],u.prototype,"relativeElevation",void 0),u=Me=a([xt("esri.views.3d.webgl.RenderCamera")],u);const hs=u,g=G(),oe=N(),b=E(),ye=E(),xe=St();let us=class extends Xt{};const ut=128,k=.5,ds=Ce(k/2,k/2,1-k/2,1-k/2);function fs(e){return e==="cross"||e==="x"}function vs(e,t=ut,i=t*k,r=0){const s=er(e,t,i,r);return new Qt(s,{mipmap:!1,wrap:{s:Xe.CLAMP_TO_EDGE,t:Xe.CLAMP_TO_EDGE},width:t,height:t,components:4,noUnpackFlip:!0,reloadable:!0})}function er(e,t=ut,i=t*k,r=0){switch(e){case"circle":default:return tr(t,i);case"square":return ir(t,i);case"cross":return sr(t,i,r);case"x":return or(t,i,r);case"kite":return rr(t,i);case"triangle":return nr(t,i);case"arrow":return ar(t,i)}}function tr(e,t){const i=e/2-.5;return K(e,ft(i,i,t/2))}function ir(e,t){return pt(e,t,!1)}function rr(e,t){return pt(e,t,!0)}function sr(e,t,i=0){return dt(e,t,!1,i)}function or(e,t,i=0){return dt(e,t,!0,i)}function nr(e,t){return K(e,vt(e/2,t,t/2))}function ar(e,t){const i=t,r=t/2,s=e/2,o=.8*i,n=ft(s,(e-t)/2-o,Math.sqrt(o*o+r*r)),l=vt(s,i,r);return K(e,(c,h)=>Math.max(l(c,h),-n(c,h)))}function pt(e,t,i){return i&&(t/=Math.SQRT2),K(e,(r,s)=>{let o=r-.5*e+.25,n=.5*e-s-.75;if(i){const l=(o+n)/Math.SQRT2;n=(n-o)/Math.SQRT2,o=l}return Math.max(Math.abs(o),Math.abs(n))-.5*t})}function dt(e,t,i,r=0){t-=r,i&&(t*=Math.SQRT2);const s=.5*t;return K(e,(o,n)=>{let l,c=o-.5*e,h=.5*e-n-1;if(i){const m=(c+h)/Math.SQRT2;h=(h-c)/Math.SQRT2,c=m}return c=Math.abs(c),h=Math.abs(h),l=c>h?c>s?Math.sqrt((c-s)*(c-s)+h*h):h:h>s?Math.sqrt(c*c+(h-s)*(h-s)):c,l-=r/2,l})}function ft(e,t,i){return(r,s)=>{const o=r-e,n=s-t;return Math.sqrt(o*o+n*n)-i}}function vt(e,t,i){const r=Math.sqrt(t*t+i*i);return(s,o)=>{const n=Math.abs(s-e)-i,l=o-e+t/2+.75,c=(t*n+i*l)/r,h=-l;return Math.max(c,h)}}function K(e,t){const i=new Uint8Array(4*e*e);for(let r=0;r<e;r++)for(let s=0;s<e;s++){const o=s+e*r;let n=t(s,r);n=n/e+.5,kt(n,i,4*o)}return i}function lr(e){return e instanceof Float32Array&&e.length>=16}function cr(e){return Array.isArray(e)&&e.length>=16}function hr(e){return lr(e)||cr(e)}class ur{constructor(){this.factor=new Qe,this.factorAlignment=new Qe}}class Qe{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}}function pr(e,t){const{vertex:i,fragment:r}=e;e.include(Zt,t),i.include(ct),i.main.add(f`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),r.main.add(f`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}function dr(e){const t=new Ui,i=e.signedDistanceFieldEnabled;t.include(ji,e),t.vertex.include(Jt,e);const{occlusionPass:r,output:s,oitPass:o}=e;if(r)return t.include(pr,e),t;const{vertex:n,fragment:l}=t;t.include(Kt),t.include(ei,e),t.include(ti,e),t.include(Li),l.include(Vi),l.include(ii),t.varyings.add("vcolor","vec4"),t.varyings.add("vtc","vec2"),t.varyings.add("vsize","vec2");const c=s===I.Highlight,h=c&&e.occlusionTestEnabled;h&&t.varyings.add("voccluded","float"),n.uniforms.add(new ri("viewport",d=>d.camera.fullViewport),new Ue("screenOffset",(d,O)=>De(ce,2*d.screenOffset[0]*O.camera.pixelRatio,2*d.screenOffset[1]*O.camera.pixelRatio)),new Ue("anchorPosition",d=>ue(d)),new we("materialColor",d=>d.color),new He("materialRotation",d=>d.rotation)),si(n),i&&(n.uniforms.add(new we("outlineColor",d=>d.outlineColor)),l.uniforms.add(new we("outlineColor",d=>Ze(d)?d.outlineColor:Vt),new He("outlineSize",d=>Ze(d)?d.outlineSize:0))),e.horizonCullingEnabled&&n.uniforms.add(new ki("pointDistanceSphere",(d,O)=>{const D=O.camera.eye,R=d.origin;return $e(R[0]-D[0],R[1]-D[1],R[2]-D[2],Pt.radius)})),e.pixelSnappingEnabled&&n.include(ct),e.hasScreenSizePerspective&&(oi(n),ni(n)),e.debugDrawLabelBorder&&t.varyings.add("debugBorderCoords","vec4"),t.attributes.add(_.UV0,"vec2"),t.attributes.add(_.COLOR,"vec4"),t.attributes.add(_.SIZE,"vec2"),t.attributes.add(_.ROTATION,"float"),t.attributes.add(_.FEATUREATTRIBUTE,"vec4"),n.code.add(e.horizonCullingEnabled?f`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return  b > 0.0 && b < a && b * b  > a * c;
}`:f`bool behindHorizon(vec3 posModel) { return false; }`),n.main.add(f`
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      if (behindHorizon(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      vec2 inputSize;
      ${P(e.hasScreenSizePerspective,f`
          inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
          vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,f`
          inputSize = size;
          vec2 screenOffsetScaled = screenOffset;`)}
      ${P(e.vvSize,f`inputSize *= vvScale(featureAttribute).xx;`)}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${P(e.occlusionTestEnabled,f`
      bool visible = testHUDVisibility(posProj);
      if (!visible) {
        vtc = vec2(0.0);
        ${P(e.debugDrawLabelBorder,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
        return;
      }`)}
      ${P(h,f`voccluded = visible ? 0.0 : 1.0;`)}
    `);const m=f`
      vec2 uv01 = floor(uv0);
      vec2 uv = uv0 - uv01;
      quadOffset.xy = (uv01 - anchorPosition) * 2.0 * combinedSize;

      ${P(e.hasRotation,f`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,v=e.pixelSnappingEnabled?i?f`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:f`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:f`posProj += quadOffset;`;n.main.add(f`
    ${m}
    ${e.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${P(s===I.ObjectAndLayerIdColor,f`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${f.float(H)};
    ${P(i,`alphaDiscard = alphaDiscard && outlineColor.a < ${f.float(H)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${v}
      gl_Position = posProj;
    }

    vtc = uv;

    ${P(e.debugDrawLabelBorder,f`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),l.uniforms.add(new ai("tex",d=>d.texture)),e.occludedFragmentFade&&(l.uniforms.add(new li("depthMap",d=>d.mainDepth)),l.uniforms.add(new ci("occludedOpacity",d=>d.hudOccludedFragmentOpacity)));const x=e.debugDrawLabelBorder?f`(isBorder > 0.0 ? 0.0 : ${f.float(H)})`:f.float(H),w=f`
    ${P(e.debugDrawLabelBorder,f`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    ${P(e.sampleSignedDistanceFieldTexelCenter,f`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;`,f`vec2 samplePos = vtc;`)}

    ${i?f`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgbaTofloat(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${x} ||
          fillPixelColor.a + outlinePixelColor.a < ${f.float(H)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${P(!c,f`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${x}) {
          discard;
        }

        ${P(!c,f`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:f`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${x}) {
            discard;
          }
          ${P(!c,f`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${P(e.occludedFragmentFade&&!c,f`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${P(!c&&e.debugDrawLabelBorder,f`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(s){case I.Color:case I.ColorEmission:t.outputs.add("fragColor","vec4",0),s===I.ColorEmission&&t.outputs.add("fragEmission","vec4",1),o===J.ColorAlpha&&t.outputs.add("fragAlpha","float",s===I.ColorEmission?2:1),l.main.add(f`
        ${w}
        ${P(o===J.FrontFace,f`fragColor.rgb /= fragColor.a;`)}
        ${P(s===I.ColorEmission,f`fragEmission = vec4(0.0);`)}
        ${P(o===J.ColorAlpha,f`fragAlpha = fragColor.a;`)}`);break;case I.ObjectAndLayerIdColor:l.main.add(f`
        ${w}
        outputObjectAndLayerIdColor();`);break;case I.Highlight:t.include(hi,e),l.main.add(f`
        ${w}
        outputHighlight(${P(h,f`voccluded == 1.0`,f`false`)});`)}return t}function Ze(e){return e.outlineColor[3]>0&&e.outlineSize>0}function ue(e){return e.textureIsSignedDistanceField?fr(e.anchorPosition,e.distanceFieldBoundingBox,ce):st(ce,e.anchorPosition),ce}function fr(e,t,i){De(i,e[0]*(t[2]-t[0])+t[0],e[1]*(t[3]-t[1])+t[1])}const ce=Ae(),vr=Object.freeze(Object.defineProperty({__proto__:null,build:dr,calculateAnchorPosition:ue},Symbol.toStringTag,{value:"Module"}));class gr extends ui{constructor(t,i){super(t,i,new pi(vr,()=>Hi(()=>import("./HUDMaterial.glsl-n0uEjdag.js").then(r=>r.H),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]),import.meta.url))),this.primitiveType=i.occlusionPass?ke.POINTS:ke.TRIANGLES}initializePipeline(t){const{oitPass:i,hasPolygonOffset:r,draped:s,output:o,depthTestEnabled:n,occlusionPass:l}=t,c=i===J.NONE,h=i===J.ColorAlpha,m=o===I.Highlight,v=n&&!s&&!h&&!l&&!m;return qi({blending:rt(o)?c?Gi:di(i):null,depthTest:n&&!s?{func:Ri.LEQUAL}:null,depthWrite:v?Wi:null,drawBuffers:fi(i,o),colorWrite:Xi,polygonOffset:r?mr:null})}}const mr={factor:0,units:-4};class T extends vi{constructor(t){super(),this.spherical=t,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.objectAndLayerIdColorInstanced=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.textureCoordinateType=gi.None,this.emissionSource=mi.None,this.discardInvisibleFragments=!0,this.hasVvInstancing=!1}}a([S()],T.prototype,"screenCenterOffsetUnitsEnabled",void 0),a([S()],T.prototype,"occlusionTestEnabled",void 0),a([S()],T.prototype,"signedDistanceFieldEnabled",void 0),a([S()],T.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),a([S()],T.prototype,"vvSize",void 0),a([S()],T.prototype,"vvColor",void 0),a([S()],T.prototype,"hasVerticalOffset",void 0),a([S()],T.prototype,"hasScreenSizePerspective",void 0),a([S()],T.prototype,"hasRotation",void 0),a([S()],T.prototype,"debugDrawLabelBorder",void 0),a([S()],T.prototype,"hasPolygonOffset",void 0),a([S()],T.prototype,"depthTestEnabled",void 0),a([S()],T.prototype,"pixelSnappingEnabled",void 0),a([S()],T.prototype,"draped",void 0),a([S()],T.prototype,"terrainDepthTest",void 0),a([S()],T.prototype,"cullAboveTerrain",void 0),a([S()],T.prototype,"occlusionPass",void 0),a([S()],T.prototype,"occludedFragmentFade",void 0),a([S()],T.prototype,"objectAndLayerIdColorInstanced",void 0),a([S()],T.prototype,"horizonCullingEnabled",void 0),a([S()],T.prototype,"isFocused",void 0);class gs extends _i{constructor(t,i){super(t,$r),this.produces=new Map([[W.HUD_MATERIAL,r=>ve(r)&&!this.parameters.drawAsLabel],[W.LABEL_MATERIAL,r=>ve(r)&&this.parameters.drawAsLabel],[W.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[W.DRAPED_MATERIAL,r=>this.parameters.draped&&ve(r)]]),this._visible=!0,this._configuration=new T(i)}getConfiguration(t,i){return this._configuration.output=t,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled=this.parameters.centerOffsetUnits==="screen",this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=i.slot===W.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||i.slot===W.OCCLUSION_PIXELS,rt(t)&&(this._configuration.debugDrawLabelBorder=!!wi.LABELS_SHOW_BORDER),this._configuration.oitPass=i.oitPass,this._configuration.terrainDepthTest=i.terrainDepthTest,this._configuration.cullAboveTerrain=i.cullAboveTerrain,this._configuration}intersect(t,i,r,s,o,n){const{options:{selectionMode:l,hud:c,excludeLabels:h},point:m,camera:v}=r,{parameters:x}=this;if(!l||!c||h&&x.isLabel||!t.visible||!m)return;const{scaleX:w,scaleY:d}=this._getScreenScale(t,v.pixelRatio);at(Oe,i),t.attributes.has(_.FEATUREATTRIBUTE)&&yr(Oe);const O=t.attributes.get(_.POSITION),D=t.attributes.get(_.SIZE),R=t.attributes.get(_.NORMAL),M=t.attributes.get(_.ROTATION),z=t.attributes.get(_.CENTEROFFSETANDDISTANCE);Ii(O.size>=3);const B=ue(x),q=this.parameters.centerOffsetUnits==="screen";for(let j=0;j<O.data.length/O.size;j++){const pe=j*O.size;U($,O.data[pe],O.data[pe+1],O.data[pe+2]),le($,$,i),le($,$,v.viewMatrix);const de=j*z.size;if(U(F,z.data[de],z.data[de+1],z.data[de+2]),!q&&($[0]+=F[0],$[1]+=F[1],F[2]!==0)){const ee=F[2];he(F,$),ae($,$,V(F,F,ee))}const fe=j*R.size;if(U(Q,R.data[fe],R.data[fe+1],R.data[fe+2]),Je(Q,Oe,v,Pe),this._applyVerticalOffsetTransformationView($,Pe,v,Te),v.applyProjection($,C),C[0]>-1){q&&(F[0]||F[1])&&(C[0]+=F[0]*v.pixelRatio,F[1]!==0&&(C[1]+=yi(F[1],Te.factorAlignment)*v.pixelRatio),v.unapplyProjection(C,$)),C[0]+=this.parameters.screenOffset[0]*v.pixelRatio,C[1]+=this.parameters.screenOffset[1]*v.pixelRatio,C[0]=Math.floor(C[0]),C[1]=Math.floor(C[1]);const ee=j*D.size;A[0]=D.data[ee],A[1]=D.data[ee+1],xi(A,Te.factor,A);const _t=Sr*v.pixelRatio;let Ee=0;x.textureIsSignedDistanceField&&(Ee=Math.min(x.outlineSize,.5*A[0])*v.pixelRatio/2),A[0]*=w,A[1]*=d;const wt=j*M.size,yt=x.rotation+M.data[wt];if(Ke(m,C[0],C[1],A,_t,Ee,yt,x,B)){const Re=r.ray;if(le(et,$,ne(Tr,v.viewMatrix)),C[0]=m[0],C[1]=m[1],v.unprojectFromRenderScreen(C,$)){const Y=E();L(Y,Re.direction);const Fe=1/X(Y);V(Y,Y,Fe),n(nt(Re.origin,$)*Fe,Y,-1,!0,1,et)}}}}}intersectDraped(t,i,r,s,o,n){const l=t.attributes.get(_.POSITION),c=t.attributes.get(_.SIZE),h=t.attributes.get(_.ROTATION),m=this.parameters,v=ue(m),{scaleX:x,scaleY:w}=this._getScreenScale(t,t.screenToWorldRatio),d=Pr*t.screenToWorldRatio;for(let O=0;O<l.data.length/l.size;O++){const D=O*l.size,R=l.data[D],M=l.data[D+1],z=O*c.size;A[0]=c.data[z],A[1]=c.data[z+1];let B=0;m.textureIsSignedDistanceField&&(B=Math.min(m.outlineSize,.5*A[0])*t.screenToWorldRatio/2),A[0]*=x,A[1]*=w;const q=O*h.size,j=m.rotation+h.data[q];Ke(s,R,M,A,d,B,j,m,v)&&o(n.dist,n.normal,-1,!1)}}createBufferWriter(){return new Mr}_updateScaleInfo(t,i,r){const s=this.parameters;s.screenSizePerspective!=null?qe(r,i,s.screenSizePerspective,t.factor):(t.factor.scale=1,t.factor.factor=0,t.factor.minScaleFactor=0),s.screenSizePerspectiveAlignment!=null?qe(r,i,s.screenSizePerspectiveAlignment,t.factorAlignment):(t.factorAlignment.factor=t.factor.factor,t.factorAlignment.scale=t.factor.scale,t.factorAlignment.minScaleFactor=t.factor.minScaleFactor)}applyShaderOffsetsView(t,i,r,s,o,n,l){const c=Je(i,r,o,Pe);return this._applyVerticalGroundOffsetView(t,c,o,l),this._applyVerticalOffsetTransformationView(l,c,o,n),this._applyPolygonOffsetView(l,c,s[3],o,l),this._applyCenterOffsetView(l,s,l),l}applyShaderOffsetsNDC(t,i,r,s,o){return this._applyCenterOffsetNDC(t,i,r,s),o!=null&&L(o,s),this._applyPolygonOffsetNDC(s,i,r,s),s}_applyPolygonOffsetView(t,i,r,s,o){const n=s.aboveGround?1:-1;let l=Math.sign(r);l===0&&(l=n);const c=n*l;if(this.parameters.shaderPolygonOffset<=0)return L(o,t);const h=bt(Math.abs(i.cosAngle),.01,1),m=1-Math.sqrt(1-h*h)/h/s.viewport[2];return V(o,t,c>0?m:1/m),o}_applyVerticalGroundOffsetView(t,i,r,s){const o=X(t),n=r.aboveGround?1:-1,l=r.computeRenderPixelSizeAtDist(o)*Bi,c=V($,i.normal,n*l);return me(s,t,c),s}_applyVerticalOffsetTransformationView(t,i,r,s){const o=this.parameters;if(!o.verticalOffset?.screenLength){if(o.screenSizePerspective||o.screenSizePerspectiveAlignment){const h=X(t);this._updateScaleInfo(s,h,i.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return t}const n=X(t),l=o.screenSizePerspectiveAlignment??o.screenSizePerspective,c=Ti(r,n,o.verticalOffset,i.cosAngle,l);return this._updateScaleInfo(s,n,i.cosAngle),V(i.normal,i.normal,c),me(t,t,i.normal)}_applyCenterOffsetView(t,i,r){const s=this.parameters.centerOffsetUnits!=="screen";return r!==t&&L(r,t),s&&(r[0]+=i[0],r[1]+=i[1],i[2]&&(he(Q,r),me(r,r,V(Q,Q,i[2])))),r}_applyCenterOffsetNDC(t,i,r,s){const o=this.parameters.centerOffsetUnits!=="screen";return s!==t&&L(s,t),o||(s[0]+=i[0]/r.fullWidth*2,s[1]+=i[1]/r.fullHeight*2),s}_applyPolygonOffsetNDC(t,i,r,s){const o=this.parameters.shaderPolygonOffset;if(t!==s&&L(s,t),o){const n=r.aboveGround?1:-1,l=n*Math.sign(i[3]);s[2]-=(l||n)*o}return s}set visible(t){this._visible=t}get visible(){const{color:t,outlineSize:i,outlineColor:r}=this.parameters,s=t[3]>=H||i>=H&&r[3]>=H;return this._visible&&s}createGLMaterial(t){return new _r(t)}calculateRelativeScreenBounds(t,i,r=$t()){return wr(this.parameters,t,i,r),r[2]=r[0]+t[0],r[3]=r[1]+t[1],r}_getScreenScale(t,i){const r=t.attributes.get(_.FEATUREATTRIBUTE);if(r==null)return{scaleX:i,scaleY:i};const s=Bt(r.data,Or);return Oi(Se,this.parameters,s),{scaleX:Se[0]*i,scaleY:Se[1]*i}}}class _r extends Si{constructor(t){super({...t,...t.material.parameters})}beginSlot(t){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(gr,t)}}function wr(e,t,i,r){r[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*i,r[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*i}function Je(e,t,i,r){return hr(t)&&(t=at(xr,t)),Lt(r.normal,e,t),le(r.normal,r.normal,i.viewInverseTransposeMatrix),r.cosAngle=be(gt,br),r}function yr(e){const t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],n=e[5],l=e[6],c=e[7],h=e[8],m=1/Math.sqrt(t*t+i*i+r*r),v=1/Math.sqrt(s*s+o*o+n*n),x=1/Math.sqrt(l*l+c*c+h*h);return e[0]=t*m,e[1]=i*m,e[2]=r*m,e[3]=s*v,e[4]=o*v,e[5]=n*v,e[6]=l*x,e[7]=c*x,e[8]=h*x,e}function Ke(e,t,i,r,s,o,n,l,c){let h=t-s-r[0]*c[0],m=h+r[0]+2*s,v=i-s-r[1]*c[1],x=v+r[1]+2*s;const w=l.distanceFieldBoundingBox;return l.textureIsSignedDistanceField&&w!=null&&(h+=r[0]*w[0],v+=r[1]*w[1],m-=r[0]*(1-w[2]),x-=r[1]*(1-w[3]),h-=o,m+=o,v-=o,x+=o),De(tt,t,i),zt(Z,e,tt,Ct(n)),Z[0]>h&&Z[0]<m&&Z[1]>v&&Z[1]<x}const Te=new ur,$=E(),Q=E(),C=G(),gt=E(),et=E(),Z=Ae(),tt=Ae(),Oe=lt(),xr=lt(),Tr=N(),F=E(),Se=E(),Or=G(),Pe={normal:gt,cosAngle:0},Sr=1,Pr=2,A=[0,0],br=Mt(0,0,1);class $r extends Pi{constructor(){super(...arguments),this.renderOccluded=bi.Occlude,this.isDecoration=!1,this.color=Ce(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=ot(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=Ce(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=G(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusEffect="none",this.draped=!1,this.isLabel=!1}}const mt=zi().vec3f(_.POSITION).vec3f(_.NORMAL).vec2f(_.UV0).vec4u8(_.COLOR).vec2f(_.SIZE).f32(_.ROTATION).vec4f(_.CENTEROFFSETANDDISTANCE).vec4f(_.FEATUREATTRIBUTE),Cr=mt.clone().vec4u8(_.OBJECTANDLAYERIDCOLOR);class Mr{constructor(){this.vertexBufferLayout=$i()?Cr:mt}elementCount(t){return 6*t.get(_.POSITION).indices.length}write(t,i,r,s,o,n){Ci(r.get(_.POSITION),t,o.position,n,6),Mi(r.get(_.NORMAL),i,o.normal,n,6);const l=r.get(_.UV0)?.data;let c=0,h=0,m=1,v=1;l&&l.length>=4&&(c=l[0],h=l[1],m=l[2],v=l[3]),m=Math.min(1.99999,m+1),v=Math.min(1.99999,v+1);let x=r.get(_.POSITION).indices.length,w=n;const d=o.uv0;for(let M=0;M<x;++M)d.set(w,0,c),d.set(w,1,h),w++,d.set(w,0,m),d.set(w,1,h),w++,d.set(w,0,m),d.set(w,1,v),w++,d.set(w,0,m),d.set(w,1,v),w++,d.set(w,0,c),d.set(w,1,v),w++,d.set(w,0,c),d.set(w,1,h),w++;Di(r.get(_.COLOR),4,o.color,n,6);const{data:O,indices:D}=r.get(_.SIZE);x=D.length;const R=o.size;w=n;for(let M=0;M<x;++M){const z=O[2*D[M]],B=O[2*D[M]+1];for(let q=0;q<6;++q)R.set(w,0,z),R.set(w,1,B),w++}if(Ai(r.get(_.ROTATION),o.rotation,n,6),r.get(_.CENTEROFFSETANDDISTANCE)?Ge(r.get(_.CENTEROFFSETANDDISTANCE),o.centerOffsetAndDistance,n,6):We(o.centerOffsetAndDistance,n,6*x),r.get(_.FEATUREATTRIBUTE)?Ge(r.get(_.FEATUREATTRIBUTE),o.featureAttribute,n,6):We(o.featureAttribute,n,6*x),s!=null){const M=r.get(_.POSITION)?.indices;if(M){const z=M.length,B=o.getField(_.OBJECTANDLAYERIDCOLOR,Fi);Ei(s,B,z,n,6)}}}}export{dr as E,ue as U,vs as a,gs as b,ds as c,ut as d,k as e,hs as i,ls as o,us as r,fs as s,ns as u};
